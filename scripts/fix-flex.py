#!/usr/bin/python3
"""
Modify files generated by flex 2.5.31

* Removes unnecessary code
* Modifies function calls
* Adds missing header
* Fixes data types
* Modifies function definitions
* Adds cleanup code

Usage:
 flex -o$output $input
 python3 fix-flex.py $output > $tmp
 mv $tmp $output

(C) Copyright 2024 Dave Beckett https://www.dajobe.org/
"""

import argparse
import logging
import re
import sys

logger = logging.getLogger(__name__)


def fix(flex_input_file):
    """
    Formats flex output according to specified rules.
    """

    with open(flex_input_file, "r") as infile:
        f_out = sys.stdout
        # Lexer symbol prefix such as 'turtle_lexer_'
        prefix = ""
        # Current function or None if out of function
        cur_function = None
        # State for current function for rules to use.
        fn_state = set()

        line_offset = 1

        f_out.write(
            """#ifdef HAVE_CONFIG_H
#include <rasqal_config.h>
#endif

#ifdef WIN32
#include <win32_rasqal_config.h>
#endif

"""
        )
        line_offset += 8

        # Read entire source lines
        s = list(enumerate(infile, start=1))
        while s:
            (line_number, line) = s.pop(0)

            # Find lexer prefix
            m = re.match(r"^void\s+(.+?)restart\s*\(.*;$", line)
            if not prefix and m:
                prefix = m.group(1)
                logger.debug(f"Line {line_number}: Lexer prefix: {prefix}")

            # Remove generated yy_fatal_error declaration and
            # definition to avoid warnings about unused/non-defined
            # static function declaration
            if re.match(
                r"^static void( yynoreturn)? yy_fatal_error\s*\(.*\)\s*\;\s*$", line
            ):
                line_offset -= 1  # skipped 1 line
                continue

            # definition
            if re.match(
                r"^static void( yynoreturn)? yy_fatal_error\s*\(.*\)\s*[^\;]\s*$", line
            ):
                line_offset -= 1  # skip current line
                while not line.endswith("}\n"):
                    (line_number, line) = s.pop(0)
                    line_offset -= 1  # skipped a line
                continue

            # Replace calls to yy_fatal_error("msg", yyscanner) with
            # YY_FATAL_ERROR("msg") macro
            line = re.sub(
                r'(^\s*)yy_fatal_error\s*\(\s*(".*")\s*,\s*yyscanner\s*\)',
                r"\1YY_FATAL_ERROR(\2)",
                line,
            )

            # flex has %option nounistd however it does not work in 2.5.31
            # It is safe to add yet another wrapper.

            m = re.match(r"^(\#include \<unistd.h\>)$", line)
            if m:
                line = """\
#ifndef YY_NO_UNISTD_H
#include <unistd.h>
#endif
"""
                line_offset += 2  # added 2 lines to output

            # Fix signed / unsigned comparison gcc 4.x warning:
            #   int n : in the macro YY_INPUT definition
            #   (size_t)num_to_read : which is silly since num_to_read is an int!
            line = re.sub(
                r"yyg->yy_n_chars, \(size_t\) num_to_read \)",
                "yyg->yy_n_chars, num_to_read )",
                line,
            )

            # Match prefixed functions and a couple of static ones starting yy_
            m = re.match(rf"^(.*?)((?:{prefix}|yy_)\w+)\s+\((\w+.*)$", line)
            if m: # and not cur_function:
                rargs, fn_name, rest = m.groups()
                # ignore defines, comments and prototypes
                if '#' not in rargs and '/*' not in rargs and ';' not in rest:
                    cur_function = fn_name
                    logger.debug(f"{line_number}: Now in {cur_function}: '{line}'")
                    fn_state = set()

            # Fix declaration of signed 'i' operating over range of yy_size_t
            if cur_function == f"{prefix}_scan_bytes":
                line = re.sub(r"int i;", "yy_size_t i;", line)

            # Add {prefix}_cleanup() call at the end of
            # {prefix}_lex_destroy() find the start of lex_destroy
            # function definition and capture prefix look for
            # lexer_free(yyscanner, yyscanner) statement within the
            # function and place the cleanup call before it
            if cur_function == f"{prefix}lex_destroy":
                m = re.match(
                    rf"^(\s*)({prefix}free\s*\(\s*yyscanner\s*,\s*yyscanner\s*\)\s*\;)\s*$",
                    line,
                )
                if m:
                    (line_prefix, rest) = m.groups()
                    line = f"""\
{line_prefix}/* clean up leaks if any before freeing yyscanner */
{line_prefix}{prefix}cleanup(yyscanner);
{line_prefix}{rest}
"""
                    line_offset += 2  # added 2 lines to output

            # Fix {prefix}_scan_bytes to take a yy_size_t len arg, not int.
            # declaration
            line = re.sub(
                rf"({prefix}_scan_bytes|yy_scan_bytes)\s+\( const char \*bytes, int len , yyscan_t yyscanner \);",
                r"\1 ( const char *bytes, yy_size_t len , yyscan_t yyscanner );",
                line,
            )
            # definition
            line = re.sub(
                rf"^YY_BUFFER_STATE ({prefix}_scan_bytes|yy_scan_bytes)\s+\(const char \* yybytes, int  _yybytes_len , yyscan_t yyscanner\)",
                r"YY_BUFFER_STATE \1 (const char * yybytes, yy_size_t _yybytes_len , yyscan_t yyscanner)",
                line,
            )

            if (
                cur_function == f"{prefix}_switch_to_buffer"
                or cur_function == f"{prefix}restart"
                or cur_function == f"{prefix}push_buffer_state"
            ):

                if "seen_ensure" not in fn_state:
                    line = re.sub(
                        r"(^\s*if\s*\(\s*!\s*)YY_CURRENT_BUFFER(\s*\)\s*\{.*$)",
                        r"\1yyg->yy_buffer_stack\2",
                        line,
                    )
                    if re.match(rf"^\s*{prefix}ensure_buffer_stack\s*\(", line):
                        fn_state.add("seen_ensure")
                else:
                    # In condition with whitespace
                    line = re.sub(
                        r"(\s+)YY_CURRENT_BUFFER(\s+)",
                        r"\1YY_CURRENT_BUFFER_LVALUE\2",
                        line,
                    )
                    # In parameter or condition
                    line = re.sub(
                        r"([,(])YY_CURRENT_BUFFER([,)])",
                        r"\1YY_CURRENT_BUFFER_LVALUE\2",
                        line,
                    )

            if cur_function == f"{prefix}_get_next_buffer":
                if "seen_yyinput" not in fn_state and re.match(r"^\s*YY_INPUT\(", line):
                    logger.debug(f"Line {line_number}: Seen YY_INPUT() in '{line}'")
                    fn_state.add("seen_yyinput")
                elif "seen_yyinput" in fn_state:
                    # Remove dead code after YY_INPUT - which is a return NULL
                    line = re.sub(
                        r"^\s*YY_CURRENT_BUFFER_LVALUE->yy_n_chars\s*=\s*yyg->yy_n_chars;",
                        "",
                        line,
                    )

            if cur_function == f"{prefix}pop_buffer_state":
                # Change last if use of YY_CURRENT_BUFFER macro to unconditional value
                line = re.sub(
                    r"^(\s*if \(\s*)YY_CURRENT_BUFFER(\s*\)\s*\{.*)$",
                    r"\1YY_CURRENT_BUFFER_LVALUE\2",
                    line,
                )

            # Make buffer size and number of characters unsigned
            line = re.sub(r"int (yy_buf_size|yy_n_chars)", r"yy_size_t \1", line)

            # Fixup pending filename renaming, see above.
            # Fix line numbers.
            line = re.sub(
                r"^\#line \d+ (.*\.[ch])", rf"#line {line_number + line_offset} \1", line
            )

            f_out.write(line)


def main():
    parser = argparse.ArgumentParser(description="Format flex output")
    parser.add_argument("INPUT", help="Input flex file")
    parser.add_argument("-d", "--debug", action="store_true", help="Enable debug mode")
    args = parser.parse_args()

    if args.debug:
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.INFO)

    fix(args.INPUT)


if __name__ == "__main__":
    main()
