<?xml version="1.0" encoding="UTF-8"?>
<chapter id="query-engine-architecture">
  <title>Rasqal Query Engine Architecture</title>

  <para>This chapter provides a comprehensive overview of the Rasqal
  RDF query engine architecture, covering the complete query
  execution pipeline, variable binding mechanisms, and architectural
  patterns that developers need to understand when working with
  Rasqal internals.</para>

  <section id="query-engine-overview">
    <title>Overview</title>

    <para>Rasqal follows a classic compiler architecture with
    distinct phases that transform SPARQL queries from text to
    results. The query engine implements a four-phase pipeline:
    parsing, transformation, algebra generation, and rowsource
    execution. Each phase has specific responsibilities and
    architectural patterns that enable efficient query processing and
    extensibility.</para>

    <para>The architecture is designed to support multiple query
    languages (SPARQL, RDQL) while maintaining a unified internal
    representation through the algebra system. This design enables
    query optimization, execution planning, and efficient processing
    of complex graph patterns and expressions.</para>

    <para>The architecture provides a robust foundation for RDF query
    processing with clear separation of concerns, extensible design,
    and efficient execution patterns. Understanding these
    architectural patterns is essential for developers working with
    Rasqal internals, implementing custom extensions, or optimizing
    query performance.</para>

  </section>

  <section id="memory-ownership">
    <title>Memory Ownership and Cleanup</title>

    <para>This section summarizes the ownership model used across the query engine. Correct ownership is critical for avoiding leaks and double frees during both normal execution and error paths.</para>

    <section id="ownership-principles">
      <title>Core Principles</title>
      <itemizedlist>
        <listitem><para>Use <literal>raptor_sequence</literal> with appropriate free handlers whenever a sequence owns allocated objects.</para></listitem>
        <listitem><para>Transfer ownership exactly once; after pushing objects into an owning sequence, do not free them manually.</para></listitem>
        <listitem><para>On error paths, free either the sequence (if it owns items) or the individual items (if ownership was not transferred).</para></listitem>
      </itemizedlist>
    </section>

    <section id="ownership-graph-patterns">
      <title>Graph Patterns and Scopes</title>
      <para>The main query owns graph patterns and maintains a hierarchy of graph pattern scopes for SPARQL 1.1 semantic isolation.</para>
      <programlisting>
rasqal_query
├── graph_patterns (raptor_sequence)     // Pattern structure hierarchy
│   └── rasqal_graph_pattern objects
│       └── execution_scope (reference)  // Points to appropriate scope
└── root_scope (rasqal_query_scope)      // Root scope with children
    ├── owned_triples (raptor_sequence)      // Triples owned by this scope
    ├── local_vars (rasqal_variables_table)  // Local variables
    └── child_scopes (raptor_sequence)       // Nested scopes
        └── rasqal_query_scope objects
      </programlisting>
      <itemizedlist>
        <listitem><para><emphasis>Pattern Owner:</emphasis> <literal>rasqal_query</literal> owns the pattern structure hierarchy.</para></listitem>
        <listitem><para><emphasis>Scope Owner:</emphasis> <literal>rasqal_query</literal> owns the root scope, which owns child scopes.</para></listitem>
        <listitem><para><emphasis>Triple Owner:</emphasis> Each scope exclusively owns its triples, preventing contamination.</para></listitem>
        <listitem><para><emphasis>Cleanup:</emphasis> Patterns and scopes are freed when the query is freed via proper reference counting.</para></listitem>
      </itemizedlist>
    </section>

    <section id="ownership-exists-expressions">
      <title>EXISTS / NOT EXISTS Expressions</title>
      <para>For EXISTS expressions, the expression frees only the sequence container; the sequence free handler must free the contained graph patterns.</para>
      <programlisting>
/* Inside expression cleanup */
case RASQAL_EXPR_EXISTS:
case RASQAL_EXPR_NOT_EXISTS:
  raptor_free_sequence(e-&gt;args);  /* sequence frees contents via handler */
  break;
      </programlisting>
      <para>When constructing such expressions, create the sequence with an appropriate free handler and transfer ownership before attaching it to the expression.</para>
    </section>

    <section id="ownership-results">
      <title>Query Results</title>
      <para>Avoid creating dummy queries when constructing results from strings. Use a NULL query; results cleanup paths already handle this.</para>
      <programlisting>
/* Correct */
results = rasqal_new_query_results2(world, NULL, type);
      </programlisting>
    </section>

    <section id="ownership-sequences">
      <title>Sequences and Free Handlers</title>
      <para>Create sequences with free handlers whenever the sequence is the owner of its elements.</para>
      <programlisting>
/* Graph patterns */
raptor_new_sequence((raptor_data_free_handler)rasqal_free_graph_pattern,
                    (raptor_data_print_handler)rasqal_graph_pattern_print);

/* Rows */
raptor_new_sequence((raptor_data_free_handler)rasqal_free_row,
                    (raptor_data_print_handler)rasqal_row_print);

/* Statements (triples) */
raptor_new_sequence((raptor_data_free_handler)raptor_free_statement,
                    (raptor_data_print_handler)raptor_statement_print);
      </programlisting>
    </section>

    <section id="ownership-error-paths">
      <title>Error Path Cleanup</title>
      <para>Choose cleanup based on whether ownership was transferred.</para>
      <programlisting>
if(sequence_created) {
  if(object_creation_failed)
    raptor_free_sequence(seq);   /* seq owns and frees items */
} else {
  rasqal_free_object(obj);       /* no transfer, free directly */
}
      </programlisting>
    </section>

    <section id="ownership-pitfalls">
      <title>Common Pitfalls</title>
      <itemizedlist>
        <listitem><para>Creating sequences without free handlers for owned items.</para></listitem>
        <listitem><para>Double-freeing items after transferring ownership to a sequence.</para></listitem>
        <listitem><para>Missing error-path cleanup that matches ownership transfer.</para></listitem>
        <listitem><para>Creating dummy objects (e.g., temporary queries) without proper lifecycle management.</para></listitem>
      </itemizedlist>
    </section>

  </section>

  <section id="query-execution-pipeline">
    <title>Query Execution Pipeline</title>

    <para>The Rasqal query execution pipeline consists of four main
    phases that transform SPARQL queries from text to results:</para>

    <section id="parsing-phase">
      <title>Parsing Phase</title>

      <para>The parsing phase takes SPARQL query text and produces an
      Abstract Syntax Tree (AST) in the
      <literal>rasqal_query</literal> structure. This phase handles
      lexical analysis, syntax analysis, and AST construction through
      the <filename>sparql_parser.y</filename> and
      <filename>sparql_lexer.l</filename> files.</para>

      <para>During parsing, the system:</para>
      <itemizedlist>
        <listitem><para>Performs lexical analysis to identify tokens and keywords</para></listitem>
        <listitem><para>Constructs syntax trees for graph patterns, expressions, and variable declarations</para></listitem>
        <listitem><para>Registers variables and establishes initial scoping</para></listitem>
        <listitem><para>Validates basic syntax and semantic constraints</para></listitem>
      </itemizedlist>

    </section>

    <section id="transformation-phase">
      <title>Transformation Phase</title>

      <para>The query transformation phase takes the raw AST from the
      parser and produces a validated and transformed query
      structure. This phase performs variable analysis, type
      checking, and optimization preparation through
      <filename>rasqal_query_transform.c</filename>.</para>

      <para>Key transformation activities include:</para>
      <itemizedlist>
        <listitem><para>Variable scope analysis and binding validation</para></listitem>
        <listitem><para>Type checking for expressions and literals</para></listitem>
        <listitem><para>Constant folding and expression simplification</para></listitem>
        <listitem><para>Preparation for algebra generation</para></listitem>
      </itemizedlist>

    </section>

    <section id="algebra-generation-phase">
      <title>Algebra Generation Phase</title>

      <para>The algebra generation phase converts the transformed
      query into a relational algebra representation, mapping graph
      patterns to algebra operator trees. This phase creates the
      foundation for query optimization and execution
      planning.</para>

      <para>The algebra system provides:</para>
      <itemizedlist>
        <listitem><para>Unified representation for different query languages</para></listitem>
        <listitem><para>Foundation for query optimization</para></listitem>
        <listitem><para>Execution planning capabilities</para></listitem>
        <listitem><para>Extensibility for new query features</para></listitem>
      </itemizedlist>

    </section>

    <section id="rowsource-execution-phase">
      <title>Rowsource Execution Phase</title>

      <para>The rowsource execution phase takes algebra operators and
      produces query results through iterator-based execution with
      lazy evaluation. This phase implements the actual data access
      and result generation.</para>

      <para>Execution characteristics include:</para>
      <itemizedlist>
        <listitem><para>Lazy evaluation for memory efficiency</para></listitem>
        <listitem><para>Iterator-based processing for large result sets</para></listitem>
        <listitem><para>Early termination support for LIMIT clauses</para></listitem>
        <listitem><para>Streaming results for interactive applications</para></listitem>
      </itemizedlist>

    </section>

  </section>

  <section id="parser-architecture">
    <title>Parser Architecture</title>

    <para>The SPARQL parser is implemented using Bison (yacc) with
    grammar rules that create AST nodes during parsing. Parser
    actions create various structures including graph patterns,
    expressions, variable registrations, and scope hierarchies for
    SPARQL 1.1 compliance.</para>

    <para>Variables are registered during parsing through
    <function>rasqal_query_add_variable</function>, which creates
    variables from literals and adds them to appropriate scopes
    within the variable scope hierarchy. The hierarchical scope system
    ensures proper SPARQL 1.1 variable isolation and inheritance.</para>

    <section id="scope-creation-during-parsing">
      <title>Scope Creation During Parsing</title>

      <para>The parser creates scope hierarchies as it encounters
      different graph pattern operators:</para>

      <itemizedlist>
        <listitem><para><emphasis>Root Scope Creation</emphasis> - The parser creates a root scope for the main query to contain outer query triples and variables</para></listitem>
        <listitem><para><emphasis>EXISTS Scope Creation</emphasis> - EXISTS/NOT EXISTS patterns trigger creation of isolated child scopes with proper parent references for variable inheritance</para></listitem>
        <listitem><para><emphasis>Triple Assignment</emphasis> - Triples are assigned to their appropriate scope during parsing, preventing later contamination</para></listitem>
        <listitem><para><emphasis>Scope Assignment</emphasis> - Graph patterns receive references to their evaluation scopes, establishing the pattern-scope relationship</para></listitem>
      </itemizedlist>

      <para>This scope creation during parsing ensures semantic isolation
      is established from the beginning of query processing, eliminating
      the need for runtime decontamination.</para>
    </section>

    <para>The modern parser architecture supports both traditional SPARQL 1.0
    patterns and SPARQL 1.1 scoped patterns through the unified scope
    management system, providing backwards compatibility while enabling
    advanced semantic features.</para>

  </section>

  <section id="algebra-system">
    <title>Algebra System</title>

    <para>Rasqal represents graph patterns as a hierarchy with
    various operator types including basic patterns, optional
    patterns, union patterns, group patterns, graph patterns, filter
    patterns, and others. Each pattern type has specific semantics
    and evaluation requirements.</para>

    <para>Basic graph patterns consist of triple patterns, which are
    the fundamental building blocks containing subject, predicate,
    object, and optional named graph context.</para>

    <para>The algebra system provides the foundation for query
    optimization and execution planning, with each operator type
    having specific performance characteristics and optimization
    opportunities.</para>

    <section id="algebra-operators">
      <title>Algebra Operators</title>

      <para>The algebra system supports the following operator types:</para>

      <variablelist>
        <varlistentry>
          <term>Basic Graph Patterns</term>
          <listitem><para>Triple patterns that form the fundamental data access units</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Optional Patterns</term>
          <listitem><para>Left outer join semantics for optional data matching</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Union Patterns</term>
          <listitem><para>Disjunctive combination of multiple graph patterns</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Group Patterns</term>
          <listitem><para>Conjunctive combination of multiple graph patterns</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Graph Patterns</term>
          <listitem><para>Named graph context for pattern evaluation</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Filter Patterns</term>
          <listitem><para>Expression-based filtering of pattern results</para></listitem>
        </varlistentry>
      </variablelist>

    </section>

  </section>

  <section id="rowsource-architecture">
    <title>Rowsource Architecture</title>

    <para>Rasqal uses the iterator pattern for query execution, with
    rowsources implementing <function>read_row</function>,
    <function>finished</function>, and <function>reset</function>
    methods. This architecture enables lazy evaluation, memory
    efficiency for large result sets, early termination for LIMIT
    clauses, and streaming results.</para>

    <para>The execution flow follows a bottom-up approach, generating
    rows from basic graph patterns and processing them through
    operators like JOIN, OPTIONAL, and FILTER before collecting
    results at the top level.</para>

    <para>The rowsource architecture provides excellent extensibility
    for new algebra operators through specialized rowsource
    implementations.</para>

    <section id="rowsource-lifecycle-management">
      <title>Rowsource Lifecycle Management</title>

      <para>Rowsources use reference counting for memory management,
      with each rowsource maintaining a usage count that tracks how
      many references exist to the rowsource. This enables safe
      sharing of rowsources between different parts of the query
      execution pipeline while ensuring proper cleanup when
      rowsources are no longer needed.</para>

      <para>The lifecycle management system implements several key principles:</para>

      <itemizedlist>
        <listitem><para><emphasis>Reference Counting</emphasis> - Each rowsource has a usage counter that is incremented when new references are created and decremented when references are released</para></listitem>
        <listitem><para><emphasis>Ownership Transfer</emphasis> - Functions that consume rowsource parameters take ownership and are responsible for cleanup</para></listitem>
        <listitem><para><emphasis>Reset Capabilities</emphasis> - Rowsources that support reset operations can be reused without requiring row caching, improving memory efficiency</para></listitem>
        <listitem><para><emphasis>Automatic Row Saving</emphasis> - Rowsources without reset handlers automatically save rows to support multiple iterations</para></listitem>
      </itemizedlist>

      <para>The reference counting system prevents memory leaks by
      ensuring that rowsources are freed when their usage count
      reaches zero. Special care is taken to avoid circular
      references between rows and rowsources, which could prevent
      proper cleanup.</para>

    </section>

    <section id="row-ownership-patterns">
      <title>Row Ownership and Memory Management</title>

      <para>Rows returned from rowsources follow specific ownership
      patterns to ensure proper memory management throughout the
      query execution pipeline. Each row maintains its own reference
      count and holds a reference to its originating
      rowsource.</para>

      <para>Key ownership principles include:</para>

      <itemizedlist>
        <listitem><para><emphasis>Caller Ownership</emphasis> -
        Functions that return rows transfer ownership to the caller,
        who becomes responsible for freeing the row</para></listitem>

        <listitem><para><emphasis>Row Reference to
	Rowsource</emphasis> - Each row holds a reference to its
	originating rowsource, ensuring the rowsource remains valid
	while the row exists</para></listitem>

        <listitem><para><emphasis>Consumption Semantics</emphasis> -
	Functions that consume rows (such as join merge operations)
	take ownership and free the consumed rows
	internally</para></listitem>

        <listitem><para><emphasis>Copy-on-Reference</emphasis> - When
	multiple references to a row are needed, the row's reference
	count is incremented rather than copying the entire row
	structure</para></listitem>

      </itemizedlist>

      <para>This ownership model ensures efficient memory usage while
      preventing both memory leaks and use-after-free conditions. The
      reference counting system automatically handles cleanup when
      objects are no longer referenced.</para>

    </section>

    <section id="rowsource-scope-integration">
      <title>Rowsource Scope Integration</title>

      <para>All rowsources now use scope-aware variable resolution to ensure proper
      variable scoping throughout the query execution pipeline.</para>

      <section id="filter-rowsource-scoping">
        <title>Filter Rowsource Scope Integration</title>

        <para>The filter rowsource uses scope-aware variable resolution to ensure
        that filter expressions respect proper variable scoping boundaries. When
        evaluating filter expressions, the rowsource creates a scope-aware lookup
        context that includes the current execution scope and appropriate search
        flags for variable inheritance.</para>

        <para>This ensures that variables referenced in filter expressions are
        resolved according to SPARQL 1.1 scoping rules, preventing access to
        out-of-scope variables and maintaining proper semantic isolation.</para>
      </section>
    </section>

    <section id="rowsource-types">
      <title>Rowsource Types</title>

      <para>The rowsource system includes several specialized types:</para>

      <variablelist>
        <varlistentry>
          <term>Triples Pattern Rowsource</term>
          <listitem><para>Handles basic graph pattern execution and triple matching</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Filter Rowsource</term>
          <listitem><para>Applies filter expressions to rows from other rowsources with scope-aware variable resolution</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Join Rowsource</term>
          <listitem><para>Implements join operations between multiple rowsources with proper row consumption semantics</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Optional Rowsource</term>
          <listitem><para>Implements left outer join semantics for optional patterns</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Union Rowsource</term>
          <listitem><para>Combines results from multiple rowsources</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Project Rowsource</term>
          <listitem><para>Selects and reorders variables in result rows</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Empty Rowsource</term>
          <listitem><para>Produces exactly one empty row for empty optional patterns and other degenerate cases, with reset capability to avoid row caching</para></listitem>
        </varlistentry>
      </variablelist>

    </section>

  </section>

  <section id="minus-semantics-and-internals">
    <title>MINUS Semantics and Internals</title>

    <para>This section documents the MINUS implementation and supporting internals validated during work on SPARQL 1.1 negation tests.</para>

    <section id="minus-compatibility">
      <title>Compatibility via Domain Intersection</title>
      <para>Rasqal implements MINUS compatibility according to SPARQL 1.1 domain-intersection semantics:</para>
      <itemizedlist>
        <listitem><para>Only variables bound on both sides (LHS and RHS) are considered shared.</para></listitem>
        <listitem><para>For shared variables, term equality is required for compatibility.</para></listitem>
        <listitem><para>If no compatible RHS row exists, the LHS row is emitted.</para></listitem>
      </itemizedlist>
      <para>Term equality is evaluated with <function>rasqal_literal_equals_flags</function>.</para>
    </section>

    <section id="minus-rowsource-lifecycle">
      <title>Rowsource Lifecycle and Row Ownership</title>
      <para>Rows returned from MINUS must carry a valid <literal>rowsource</literal> pointer for correct deep-copy behavior. When emitting an LHS row:</para>
      <itemizedlist>
        <listitem><para>Set the row's <literal>rowsource</literal> to the MINUS rowsource if not already set.</para></listitem>
        <listitem><para>Create a deep copy with <function>rasqal_new_row_from_row_deep</function>.</para></listitem>
        <listitem><para>Attach the new row to the MINUS rowsource and propagate the row offset.</para></listitem>
      </itemizedlist>
      <para>This avoids a null <literal>row-&gt;rowsource</literal> dereference during deep copy.</para>
    </section>

    <section id="filter-ebv-and-unbound">
      <title>FILTER EBV and Unbound Operands</title>
      <para>FILTER comparison operators (EQ, NEQ, LT, GT, LE, GE) treat unbound operands as FALSE, filtering the solution rather than raising errors, per SPARQL 1.1. This is implemented in <filename>rasqal_expr_evaluate.c</filename>.</para>
    </section>

    <section id="exists-variable-usage">
      <title>EXISTS/NOT EXISTS Variable Usage Analysis</title>
      <para>Variables referenced solely inside EXISTS/NOT EXISTS must not trigger "not bound and not used" errors at transform time. The transformer supports detection in both FILTER expressions and EXISTS-local BGPs. This analysis is performed in <filename>rasqal_query_transform.c</filename> and is limited to variable mention detection; it does not evaluate sub-queries.</para>
    </section>
  </section>

  <section id="variable-scoping-and-rows">
    <title>Variable Scoping, Rows, and Headers</title>

    <para>Result rows carry values and a back-pointer to the producing rowsource. The rowsource header defines variable ordering for row printing and projection. Key rules:</para>
    <itemizedlist>
      <listitem><para>Always attach emitted rows to the producing rowsource via <function>rasqal_row_set_rowsource</function>.</para></listitem>
      <listitem><para>Preserve <literal>offset</literal> when creating derived rows to maintain stable ordering.</para></listitem>
      <listitem><para>Use <function>rasqal_rowsource_get_variable_by_offset</function> for header-based name lookup when printing rows.</para></listitem>
    </itemizedlist>
  </section>

  <section id="exists-evaluation-architecture">
    <title>EXISTS and NOT EXISTS Evaluation Architecture</title>

    <para>The EXISTS and NOT EXISTS evaluation system implements a unified
    mode-aware architecture that provides efficient pattern matching with
    optimized short-circuiting for both EXISTS and NOT EXISTS operations.
    This system handles all SPARQL pattern types including basic patterns,
    GROUP patterns, UNION patterns, OPTIONAL patterns, GRAPH patterns, and
    FILTER patterns with proper semantic isolation and performance optimization.</para>

    <section id="exists-unified-mode-system">
      <title>Unified Mode-Aware Evaluation</title>

      <para>The EXISTS evaluation architecture uses a unified system based on
      the <literal>rasqal_exists_mode</literal> enumeration that enables
      single evaluation paths optimized for both EXISTS and NOT EXISTS
      semantics:</para>

      <programlisting>
typedef enum {
  RASQAL_EXISTS_MODE_EXISTS = 0,      /* Standard EXISTS evaluation */
  RASQAL_EXISTS_MODE_NOT_EXISTS = 1   /* Optimized NOT EXISTS evaluation */
} rasqal_exists_mode;
      </programlisting>

      <para>This design eliminates code duplication while enabling
      mode-specific optimizations:</para>

      <itemizedlist>
        <listitem><para><emphasis>EXISTS Mode</emphasis> - Succeeds when any
        pattern matches, enabling early success termination</para></listitem>
        <listitem><para><emphasis>NOT EXISTS Mode</emphasis> - Succeeds when
        patterns fail to match, enabling early failure detection</para></listitem>
      </itemizedlist>

    </section>

    <section id="exists-pattern-handlers">
      <title>Pattern-Specific Evaluation Handlers</title>

      <para>The unified architecture provides specialized internal handlers
      for each SPARQL pattern type, each implementing mode-aware evaluation
      with appropriate short-circuiting optimizations:</para>

      <variablelist>
        <varlistentry>
          <term>Basic Pattern Handler</term>
          <listitem><para><function>rasqal_evaluate_basic_pattern_internal</function>
          - Handles triple pattern evaluation with proper multi-triple
          conjunctive semantics. Fixes critical bug where only the first
          triple was evaluated.</para></listitem>
        </varlistentry>

        <varlistentry>
          <term>GROUP Pattern Handler</term>
          <listitem><para><function>rasqal_evaluate_group_pattern_internal</function>
          - Implements conjunctive (AND) semantics with early termination.
          EXISTS mode fails on first sub-pattern failure, NOT EXISTS mode
          succeeds on first sub-pattern failure.</para></listitem>
        </varlistentry>

        <varlistentry>
          <term>UNION Pattern Handler</term>
          <listitem><para><function>rasqal_evaluate_union_pattern_internal</function>
          - Implements disjunctive (OR) semantics with optimized short-circuiting.
          EXISTS mode succeeds on first sub-pattern success, NOT EXISTS mode
          succeeds on first sub-pattern failure.</para></listitem>
        </varlistentry>

        <varlistentry>
          <term>OPTIONAL Pattern Handler</term>
          <listitem><para><function>rasqal_evaluate_optional_pattern_internal</function>
          - Evaluates required pattern only (optional part doesn't affect EXISTS
          result). Provides immediate mode-aware termination based on required
          pattern result.</para></listitem>
        </varlistentry>

        <varlistentry>
          <term>GRAPH Pattern Handler</term>
          <listitem><para><function>rasqal_evaluate_graph_pattern_internal</function>
          - Handles named graph context evaluation with origin support.
          Maintains mode awareness while supporting both basic and complex
          sub-patterns.</para></listitem>
        </varlistentry>
      </variablelist>

    </section>

    <section id="exists-optimization-strategies">
      <title>Optimization Strategies</title>

      <para>The EXISTS evaluation system employs several optimization strategies
      that significantly improve query performance:</para>

      <section id="exists-short-circuiting">
        <title>Mode-Aware Short-Circuiting</title>

        <para>Different short-circuiting strategies are applied based on the
        evaluation mode:</para>

        <itemizedlist>
          <listitem><para><emphasis>EXISTS Short-Circuiting</emphasis> -
          Terminates immediately when any pattern succeeds, avoiding
          unnecessary evaluation of remaining patterns</para></listitem>
          <listitem><para><emphasis>NOT EXISTS Short-Circuiting</emphasis> -
          Terminates immediately when any pattern fails, providing optimal
          performance for negation operations</para></listitem>
        </itemizedlist>

        <para>This approach provides significant performance benefits for
        complex patterns with multiple alternatives or conditions.</para>

      </section>

      <section id="exists-direct-evaluation">
        <title>Direct NOT EXISTS Evaluation</title>

        <para>The system provides direct NOT EXISTS evaluation instead of
        negating EXISTS results:</para>

        <programlisting>
/* Enhanced NOT EXISTS evaluation */
not_exists_result = rasqal_evaluate_not_exists_pattern_with_origin(
    gp, triples_source, query, outer_row, graph_origin);

/* Instead of: !rasqal_evaluate_exists_pattern(...) */
        </programlisting>

        <para>This eliminates unnecessary computation and enables immediate
        short-circuiting optimizations specific to NOT EXISTS semantics.</para>

      </section>

    </section>

    <section id="exists-multi-triple-semantics">
      <title>Multi-Triple Pattern Semantics</title>

      <para>The EXISTS evaluation system correctly implements SPARQL conjunctive
      semantics for multi-triple patterns, fixing a critical bug in the previous
      implementation:</para>

      <section id="exists-conjunctive-evaluation">
        <title>Conjunctive Pattern Processing</title>

        <para>All triples within a basic graph pattern must match for the
        pattern to succeed:</para>

        <programlisting>
/* Example: All three triples must match */
FILTER NOT EXISTS { 
    ?person foaf:name ?name .      # Triple 1
    ?person foaf:age ?age .        # Triple 2  
    ?person foaf:email ?email      # Triple 3
}
        </programlisting>

        <para>The evaluation system processes all triples and requires complete
        matches for EXISTS success, or complete failure for NOT EXISTS success.</para>

      </section>

      <section id="exists-variable-binding">
        <title>Variable Binding in EXISTS Context</title>

        <para>EXISTS evaluation maintains proper variable scoping isolation
        while allowing variable binding during pattern instantiation:</para>

        <itemizedlist>
          <listitem><para>Variables from outer query scope are available for
          pattern instantiation</para></listitem>
          <listitem><para>Variables bound within EXISTS patterns remain isolated
          and don't affect outer query</para></listitem>
          <listitem><para>Named graph context is properly maintained through
          origin parameters</para></listitem>
        </itemizedlist>

      </section>

    </section>

    <section id="exists-performance-characteristics">
      <title>Performance Characteristics</title>

      <para>The unified EXISTS evaluation architecture provides several
      performance benefits:</para>

      <variablelist>
        <varlistentry>
          <term>Code Efficiency</term>
          <listitem><para>Eliminated over 200 lines of duplicate code through
          unified architecture, reducing maintenance burden and improving
          consistency</para></listitem>
        </varlistentry>

        <varlistentry>
          <term>Execution Efficiency</term>
          <listitem><para>Direct evaluation paths eliminate wrapper function
          overhead and enable immediate short-circuiting based on pattern
          evaluation results</para></listitem>
        </varlistentry>

        <varlistentry>
          <term>Memory Efficiency</term>
          <listitem><para>Reduced function call stack depth and eliminated
          redundant pattern evaluation paths, improving memory usage patterns</para></listitem>
        </varlistentry>

        <varlistentry>
          <term>Debug Efficiency</term>
          <listitem><para>Unified debug output system using lookup tables
          provides clear tracing without repeated string operations</para></listitem>
        </varlistentry>
      </variablelist>

    </section>

    <section id="exists-integration-patterns">
      <title>Integration with Query Engine</title>

      <para>The EXISTS evaluation system integrates seamlessly with other
      query engine components:</para>

      <itemizedlist>
        <listitem><para><emphasis>Expression System Integration</emphasis> -
        EXISTS expressions use the unified evaluation system through
        <function>rasqal_expression_evaluate_not_exists</function> with
        proper scope context</para></listitem>

        <listitem><para><emphasis>Variable Scoping Integration</emphasis> -
        EXISTS evaluation respects hierarchical variable scoping and maintains
        proper isolation boundaries</para></listitem>

        <listitem><para><emphasis>Triples Source Integration</emphasis> -
        Pattern evaluation works with any triples source implementation,
        supporting both default and named graph contexts</para></listitem>

        <listitem><para><emphasis>Error Handling Integration</emphasis> -
        Consistent error propagation through evaluation chains with proper
        cleanup on error conditions</para></listitem>
      </itemizedlist>

    </section>

  </section>

  <section id="expression-evaluation-system">
    <title>Expression Evaluation System</title>

    <para>Rasqal supports various expression types including
    literals, functions, variables, logical operators, comparison
    operators, and specialized operators. Each expression type has
    specific evaluation semantics and requirements.</para>

    <para>Expressions are evaluated within a
    <literal>rasqal_evaluation_context</literal> that provides access
    to the world, query, flags, comparison flags, and current row
    bindings. The expression evaluation system has been enhanced with
    scope-aware variable resolution to support proper SPARQL 1.1
    variable scoping semantics.</para>

    <para>The scope-aware expression evaluation system ensures that
    variable lookups during expression evaluation respect the proper
    scope boundaries and inheritance rules, enabling complex SPARQL 1.1
    features like nested EXISTS patterns and variable isolation.</para>

    <section id="expression-types">
      <title>Expression Types</title>

      <para>The expression system supports the following types:</para>

      <variablelist>
        <varlistentry>
          <term>Literals</term>
          <listitem><para>Constant values including strings, numbers, booleans, and URIs</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Variables</term>
          <listitem><para>Variable references that resolve to current bindings</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Functions</term>
          <listitem><para>Built-in and user-defined function calls</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Logical Operators</term>
          <listitem><para>AND, OR, NOT operations on boolean expressions</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Comparison Operators</term>
          <listitem><para>Equality, inequality, and ordering comparisons</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Arithmetic Operators</term>
          <listitem><para>Mathematical operations on numeric expressions</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>EXISTS/NOT EXISTS Operators</term>
          <listitem><para>Pattern existence testing with unified mode-aware
          evaluation and optimized short-circuiting (see <xref linkend="exists-evaluation-architecture"/>)</para></listitem>
        </varlistentry>
      </variablelist>

    </section>

  </section>

      <section id="variable-binding-system">
    <title>Variable Binding System</title>

    <para>The variable binding system is built on a comprehensive query scope
    architecture that ensures proper SPARQL 1.1 variable isolation and inheritance
    semantics. This system has completely eliminated the previous matrix-based approach
    in favor of dynamic, scope-aware variable resolution that provides true SPARQL 1.1
    semantic compliance while maintaining excellent performance.</para>

    <section id="query-scope-architecture">
      <title>Query Scope Architecture</title>

      <para>The query scope architecture implements hierarchical scope management
      to ensure proper SPARQL 1.1 variable isolation and inheritance semantics.
      Each query pattern operator creates an isolated scope with its own triple
      ownership and variable visibility rules.</para>

      <para><emphasis>Scope Types Supported:</emphasis></para>
      <itemizedlist>
        <listitem><para><literal>ROOT</literal> - Main query scope for outer query patterns</para></listitem>
        <listitem><para><literal>EXISTS</literal> - EXISTS pattern scope with variable inheritance</para></listitem>
        <listitem><para><literal>NOT_EXISTS</literal> - NOT EXISTS pattern scope for negation</para></listitem>
        <listitem><para><literal>MINUS</literal> - MINUS pattern scope for set difference</para></listitem>
        <listitem><para><literal>UNION</literal> - UNION pattern scope for disjunctive patterns</para></listitem>
        <listitem><para><literal>SUBQUERY</literal> - Subquery scope with complete isolation</para></listitem>
        <listitem><para><literal>GROUP</literal> - Nested group pattern scope for isolation</para></listitem>
      </itemizedlist>
    </section>

    <section id="scope-aware-variable-resolution">
      <title>Scope-Aware Variable Resolution</title>

      <para>The variable resolution system uses hierarchical scope-aware lookup
      that respects SPARQL 1.1 semantic boundaries. Variables are resolved
      through a scope hierarchy with proper inheritance and isolation rules.</para>

      <para><emphasis>Resolution Algorithm:</emphasis></para>
      <orderedlist>
        <listitem><para>Start with current execution scope</para></listitem>
        <listitem><para>Search local variables in current scope</para></listitem>
        <listitem><para>If not found and inheritance allowed, search parent scope</para></listitem>
        <listitem><para>Continue up hierarchy until root scope</para></listitem>
        <listitem><para>Return first match with proper precedence rules</para></listitem>
      </orderedlist>

      <para>This ensures that variable lookups respect SPARQL 1.1 scoping
      requirements while maintaining efficient resolution performance.</para>

      <para><emphasis>Implementation Status:</emphasis> The scope-aware variable
      resolution system is fully implemented and operational across all query execution
      components. Core functions like <function>rasqal_resolve_variable_with_scope</function>,
      <function>rasqal_query_variable_is_bound</function>, and all rowsource variable
      resolution use dynamic scope queries instead of static matrix lookups. This provides
      true SPARQL 1.1 semantic compliance while maintaining backward compatibility and
      excellent performance. The system supports all SPARQL 1.1 scope types including
      EXISTS, NOT EXISTS, MINUS, UNION, GROUP, and subquery patterns.</para>

      <section id="matrix-elimination">
        <title>Variable Use Map Elimination</title>

        <para>The previous implementation used a matrix-based approach for tracking
        variable usage across graph patterns. This system has been completely eliminated
        in favor of the dynamic scope architecture:</para>

        <itemizedlist>
          <listitem><para><emphasis>Previous System:</emphasis> Static 2D matrix
          (<literal>variables_use_map</literal>) tracking variable usage across all
          graph patterns - required pre-computation and significant memory allocation</para></listitem>
          <listitem><para><emphasis>New System:</emphasis> Dynamic scope hierarchy
          with runtime variable resolution - zero matrix overhead and true SPARQL 1.1
          semantic compliance</para></listitem>
        </itemizedlist>

        <para><emphasis>Benefits:</emphasis></para>
        <itemizedlist>
          <listitem><para>Significant memory savings - no large matrix allocations</para></listitem>
          <listitem><para>True SPARQL 1.1 scoping semantics with proper variable isolation</para></listitem>
          <listitem><para>Dynamic resolution eliminates static analysis limitations</para></listitem>
          <listitem><para>Simplified architecture with single scope system instead of parallel systems</para></listitem>
        </itemizedlist>
      </section>
    </section>

    <section id="variable-lifecycle">
      <title>Variable Lifecycle</title>

      <para>Variables follow a specific lifecycle through the query
      execution process:</para>

      <orderedlist>
        <listitem><para><emphasis>Registration</emphasis> - Variables
	are registered during parsing and added to the query's
	variable table</para></listitem>

        <listitem><para><emphasis>Analysis</emphasis> - The query
	transformer analyzes variable usage and binding
	patterns</para></listitem>

        <listitem><para><emphasis>Binding</emphasis> - Variables
	receive values during query execution</para></listitem>

        <listitem><para><emphasis>Propagation</emphasis> - Variable
	bindings are propagated to sub-queries and
	expressions</para></listitem>

        <listitem><para><emphasis>Cleanup</emphasis> - Variable
	bindings are cleaned up after query
	completion</para></listitem>

      </orderedlist>

    </section>

    <section id="variable-access-patterns">
      <title>Variable Access Patterns</title>

      <para>Rasqal provides multiple patterns for accessing variable bindings
      with scope awareness:</para>

      <variablelist>
        <varlistentry>
          <term>Expression Context Access</term>
          <listitem><para>Uses
	  <function>rasqal_literal_value</function> during expression
	  evaluation within an active evaluation context, with scope-aware
	  variable resolution</para></listitem>

        </varlistentry>
        <varlistentry>
          <term>Scope-Aware Variable Lookup</term>
          <listitem><para>Uses scope-aware variable resolution functions
          for hierarchical variable resolution that respects scope boundaries</para></listitem>

        </varlistentry>
        <varlistentry>
          <term>Direct Variable Access</term>
          <listitem><para>Used for direct access to variable bindings
	  in pattern instantiation, with scope context passed to ensure
	  proper variable resolution</para></listitem>

        </varlistentry>
      </variablelist>

      <para>The scope-aware access patterns ensure that variable lookups
      respect SPARQL 1.1 semantic boundaries while maintaining backwards
      compatibility with existing code.</para>

    </section>

    <section id="scope-debugging-tools">
      <title>Internal Scope Debugging Tools</title>

      <para>Rasqal provides internal debugging tools for analyzing
      query scope hierarchies and variable resolution patterns during development.
      These tools are primarily used by Rasqal developers for debugging
      complex SPARQL queries and scope-related issues.</para>

      <section id="scope-variable-usage-analysis">
        <title>Scope Variable Usage Analysis</title>

        <para>The <function>rasqal_query_scope_print_scope_variable_usage</function>
        function provides detailed analysis of variable usage within query
        scopes. This is an internal debugging function used during development
        and is not part of the public API:</para>

        <programlisting>
/* Internal debugging function - NOT in public API */
static void rasqal_query_scope_print_scope_variable_usage(FILE* fh, rasqal_query* query);

/* Usage within Rasqal codebase for debugging only */
rasqal_query_scope_print_scope_variable_usage(RASQAL_DEBUG_FH, query);
        </programlisting>

        <para><emphasis>Output Format:</emphasis></para>
        <programlisting>
Query Variable Scope Analysis:
Variables (3 total):
  ?s: BOUND
  ?p: BOUND
  ?o: BOUND

Scope Hierarchy:
┌─ ROOT_0 (scope_id=0, type=0)
│  ├─ Local Variables: 0
│  ├─ Owned Triples: 2
│  └─ Child Scopes: 1
│     └─ EXISTS_1 (scope_id=1, type=1, parent=ROOT_0)
│        ├─ Local Variables: 0
│        ├─ Owned Triples: 1
│        └─ Child Scopes: 0
        </programlisting>

        <para>This function displays:</para>
        <itemizedlist>
          <listitem><para>Variable binding status for all query variables</para></listitem>
          <listitem><para>Complete scope hierarchy with parent-child relationships</para></listitem>
          <listitem><para>Triple ownership information for each scope</para></listitem>
          <listitem><para>Local variable counts and scope isolation details</para></listitem>
        </itemizedlist>
      </section>

      <section id="scope-hierarchy-visualization">
        <title>Scope Hierarchy Visualization</title>

        <para>The scope hierarchy visualization uses Unicode box-drawing
        characters to create a tree-like representation of the query's
        scope structure:</para>

        <programlisting>
/* Internal function for hierarchical scope display */
static void rasqal_query_scope_print_variable_analysis(
    FILE* fh,
    rasqal_query_scope* scope,
    int depth
);
        </programlisting>

        <para>The visualization shows:</para>
        <itemizedlist>
          <listitem><para>Scope type and unique identifier</para></listitem>
          <listitem><para>Parent-child relationships with proper indentation</para></listitem>
          <listitem><para>Resource ownership (triples, variables)</para></listitem>
          <listitem><para>Scope isolation boundaries</para></listitem>
        </itemizedlist>

        <para>This debugging tool is invaluable for:</para>
        <itemizedlist>
          <listitem><para>Understanding complex query scope hierarchies</para></listitem>
          <listitem><para>Debugging variable resolution issues</para></listitem>
          <listitem><para>Verifying scope isolation correctness</para></listitem>
          <listitem><para>Analyzing triple ownership patterns</para></listitem>
        </itemizedlist>
      </section>

      <section id="debugging-integration">
        <title>Internal Debugging Integration</title>

        <para>The scope debugging tools are integrated throughout the
        query processing pipeline for internal development use:</para>

        <itemizedlist>
          <listitem><para><emphasis>Parser Integration:</emphasis> Scope creation
          can be traced during parsing with detailed hierarchy information</para></listitem>
          <listitem><para><emphasis>Transformation Integration:</emphasis> Variable
          analysis and scope validation during query transformation</para></listitem>
          <listitem><para><emphasis>Execution Integration:</emphasis> Scope-aware
          variable resolution tracing during query execution</para></listitem>
        </itemizedlist>

        <para>These internal tools provide comprehensive visibility into the scope
        architecture, making it easier for Rasqal developers to debug complex SPARQL queries and
        understand variable scoping behavior.</para>
      </section>

    </section>

  </section>

  <section id="graph-pattern-management">
    <title>Graph Pattern Management</title>

    <para>Graph patterns are built during parsing through functions
    like
    <function>rasqal_new_basic_graph_pattern_from_formula</function>,
    which creates patterns from formula structures. The parser
    automatically adds pattern triples to the main query's triple
    sequence during pattern construction, which can cause variable
    scoping issues that require special handling.</para>

    <para>Filter expressions are attached to graph patterns and
    evaluated during pattern execution. The integration between graph
    patterns and filter expressions creates complex evaluation
    requirements, especially for nested patterns.</para>

    <para>Pattern integration assumes global pattern integration,
    requiring special handling for scoped sub-patterns that need
    isolation for proper scoping.</para>

  </section>



  <section id="query-transformation-system">
    <title>Query Transformation System</title>

    <para>The query transformer performs comprehensive variable analysis in <function>rasqal_query_build_variables_use</function>, analyzing variable scope and binding context, ensuring proper variable binding, and identifying unbound variable usage.</para>

    <para>The transformer prepares queries for optimization through constant folding, filter pushdown, and join reordering preparation. This phase is critical for query performance and correctness.</para>

    <section id="transformation-phases">
      <title>Transformation Phases</title>

      <para>The query transformation system performs several key phases,
      enhanced with scope-aware validation for SPARQL 1.1 compliance:</para>

      <orderedlist>
        <listitem><para><emphasis>Variable Analysis</emphasis> - Analyzes variable usage patterns and binding requirements across scope hierarchies</para></listitem>
        <listitem><para><emphasis>Scope Validation</emphasis> - Validates hierarchical variable scoping, ensures proper scope boundaries, and identifies unbound variables within appropriate scope contexts</para></listitem>
        <listitem><para><emphasis>Type Checking</emphasis> - Validates expression types and literal compatibility with scope-aware variable resolution</para></listitem>
        <listitem><para><emphasis>Constant Folding</emphasis> - Evaluates constant expressions at compile time while respecting scope isolation</para></listitem>
        <listitem><para><emphasis>Scope Optimization</emphasis> - Optimizes scope hierarchies and validates scope relationships for efficient evaluation</para></listitem>
        <listitem><para><emphasis>Optimization Preparation</emphasis> - Prepares query structures for optimization with scope-aware analysis</para></listitem>
      </orderedlist>

      <para>The scope-enhanced transformation phases ensure that SPARQL 1.1
      semantic isolation requirements are validated and maintained throughout
      the query processing pipeline.</para>

    </section>

  </section>

  <section id="triples-source-interface">
    <title>Triples Source Interface</title>

    <para>Rasqal abstracts data access through the triples source
    interface, which provides an abstract interface for data store
    access. This interface includes initialization, next match
    iteration, and finished state management.</para>

    <para>The triples source pattern involves binding known variables
    in triple patterns, querying the underlying data store, and
    iterating through matching triples.</para>

    <para>A key limitation is that the expression evaluation context
    doesn't provide direct access to triples source, making complex
    evaluation architecturally challenging and forcing reliance on
    heuristics rather than actual data lookup.</para>

    <section id="triples-source-operations">
      <title>Triples Source Operations</title>

      <para>The triples source interface provides the following operations:</para>

      <variablelist>
        <varlistentry>
          <term>Initialization</term>
          <listitem><para>Sets up the triples source for query execution</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Triple Matching</term>
          <listitem><para>Finds triples matching specified patterns</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Iteration</term>
          <listitem><para>Iterates through matching triples</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Cleanup</term>
          <listitem><para>Releases resources after query completion</para></listitem>
        </varlistentry>
      </variablelist>

    </section>

  </section>

  <section id="error-handling-and-validation">
    <title>Error Handling and Validation</title>

    <para>Rasqal implements multi-level validation across parse-time,
    transform-time, and runtime phases. Parse-time validation handles
    syntax and basic semantic validation, transform-time validation
    performs variable binding and scope validation, and runtime
    validation handles type checking and evaluation errors.</para>

    <para>Error propagation uses error flags passed through
    evaluation chains with early termination on error
    conditions.</para>

    <para>The query validation pipeline ensures queries go through
    comprehensive validation including lexical, syntactic, semantic,
    and runtime phases.</para>

    <section id="resource-management-validation">
      <title>Resource Management Validation</title>

      <para>The system includes comprehensive resource management
      validation to prevent memory leaks and corruption:</para>

      <itemizedlist>
        <listitem><para><emphasis>Reference Count
	Validation</emphasis> - Debug builds track reference count
	manipulations to detect leaks and premature
	frees</para></listitem>

        <listitem><para><emphasis>Ownership Validation</emphasis> -
	Functions validate that they properly transfer ownership of
	consumed parameters</para></listitem>

        <listitem><para><emphasis>Lifecycle Validation</emphasis> -
	The system validates that objects follow proper
	initialization and cleanup sequences</para></listitem>

        <listitem><para><emphasis>Memory Leak Detection</emphasis> -
	Integration with tools like AddressSanitizer enables
	automated detection of memory management
	issues</para></listitem>

      </itemizedlist>

      <para>These validation mechanisms have proven essential for
      maintaining system reliability, particularly in complex query
      patterns that stress the memory management system.</para>

    </section>

    <section id="validation-levels">
      <title>Validation Levels</title>

      <para>Rasqal implements validation at multiple levels:</para>

      <variablelist>
        <varlistentry>
          <term>Lexical Validation</term>
          <listitem><para>Validates token recognition and basic syntax</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Syntactic Validation</term>
          <listitem><para>Validates grammar rules and structure</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Semantic Validation</term>
          <listitem><para>Validates variable binding and scope</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Runtime Validation</term>
          <listitem><para>Validates expression evaluation and type checking</para></listitem>
        </varlistentry>
      </variablelist>

    </section>

  </section>



  <section id="performance-considerations">
    <title>Performance Considerations</title>

    <para>Lazy evaluation provides memory efficiency for large
    datasets, early termination possibilities, and streaming result
    processing. This architecture enables efficient handling of large
    result sets and complex queries.</para>

    <para>Optimization opportunities include leveraging RDF store
    indices, moving filters closer to data through filter pushdown,
    optimizing join execution order, and evaluating constants at
    compile time.</para>

    <para>Bottleneck areas include frequent literal value lookups
    during variable binding, complex expression tree evaluation,
    triple pattern evaluation, and frequent object creation and
    destruction during memory allocation.</para>

    <section id="memory-management-performance">
      <title>Memory Management Performance</title>

      <para>The reference counting system provides memory management
      with deterministic cleanup, but requires careful attention to
      avoid memory leaks:</para>

      <itemizedlist>
        <listitem><para><emphasis>Reference Count Overhead</emphasis>
        - Each object access requires reference count manipulation,
        which can become expensive in tight loops.</para></listitem>
        <listitem><para><emphasis>Circular Reference
        Prevention</emphasis> - Careful design is needed to avoid
        circular references that prevent cleanup.</para></listitem>
        <listitem><para><emphasis>Reset Handler Benefits</emphasis> -
        Rowsources with reset handlers avoid the overhead of row
        caching and the associated memory usage.</para></listitem>
        <listitem><para><emphasis>Consumption Semantics</emphasis> -
        Proper implementation of consumption semantics in functions
        like join operations prevents double-free conditions and
        improves performance.</para></listitem>
      </itemizedlist>

    </section>

    <section id="optimization-strategies">
      <title>Optimization Strategies</title>

      <para>Rasqal employs several optimization strategies:</para>

      <variablelist>
        <varlistentry>
          <term>Constant Folding</term>
          <listitem><para>Evaluates constant expressions at compile time</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Filter Pushdown</term>
          <listitem><para>Moves filters closer to data sources</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Join Reordering</term>
          <listitem><para>Optimizes join execution order</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Early Termination</term>
          <listitem><para>Stops processing when sufficient results are found</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>EXISTS Pattern Optimization</term>
          <listitem><para>Mode-aware short-circuiting for EXISTS and NOT EXISTS
          patterns provides immediate termination based on pattern evaluation results
          (see <xref linkend="exists-short-circuiting"/>)</para></listitem>
        </varlistentry>
      </variablelist>

    </section>

  </section>

  <section id="module-architecture">
    <title>Module Architecture and Organization</title>

    <para>Rasqal's module architecture has been enhanced to support
    the hierarchical scope system while maintaining clean separation
    of concerns and extensible design patterns.</para>

    <section id="scope-management-modules">
      <title>Scope Management Modules</title>

      <para>The scope architecture is implemented across dedicated modules that
      provide the foundation for SPARQL 1.1 semantic isolation:</para>

      <variablelist>
        <varlistentry>
          <term>rasqal_query_scope.c</term>
          <listitem><para>Core scope management functions including creation,
          destruction, hierarchy management, and variable visibility computation.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>rasqal_query_transform.c</term>
          <listitem><para>Enhanced query transformation with scope hierarchy
          building and scope-aware variable analysis.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>rasqal_rowsource_filter.c</term>
          <listitem><para>Filter rowsource implementation with scope-aware
          variable resolution and proper variable scoping boundaries.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>rasqal_expression.c</term>
          <listitem><para>Enhanced expression evaluation with scope-aware
          variable resolution and scope context propagation.</para></listitem>
        </varlistentry>
      </variablelist>

    </section>

    <section id="module-integration-patterns">
      <title>Module Integration Patterns</title>

      <para>The scope architecture follows established Rasqal patterns
      for module integration:</para>

      <itemizedlist>
        <listitem><para><emphasis>Reference Counting</emphasis> - Scope
        objects use proper reference counting for memory management</para></listitem>
        <listitem><para><emphasis>C89 Compatibility</emphasis> - All scope
        functions maintain C89 compatibility for broad system support</para></listitem>
        <listitem><para><emphasis>Consistent Naming</emphasis> - Scope
        functions follow Rasqal naming conventions with appropriate
        prefixes</para></listitem>
        <listitem><para><emphasis>Error Handling</emphasis> - Scope modules
        implement consistent error reporting and cleanup patterns</para></listitem>
      </itemizedlist>

    </section>

  </section>

  <section id="extensibility-and-customization">
    <title>Extensibility and Customization</title>

    <para>Rasqal's architecture provides several extension points for
    customizing query behavior and adding new functionality:</para>

    <section id="custom-functions">
      <title>Custom Functions</title>

      <para>Developers can add custom functions to the expression
      system by implementing function registration and evaluation
      callbacks. This enables domain-specific functionality and
      integration with external systems.</para>

    </section>

    <section id="custom-triples-sources">
      <title>Custom Triples Sources</title>

      <para>The triples source interface allows implementing custom
      data access layers for different storage systems. This enables
      integration with various RDF stores and data sources.</para>

    </section>

    <section id="custom-rowsources">
      <title>Custom Rowsources</title>

      <para>The rowsource architecture supports implementing custom
      execution operators for specialized query processing
      requirements. This enables advanced optimization and
      domain-specific query features.</para>

      <para>When implementing custom rowsources, developers must
      carefully follow the established memory management
      patterns:</para>

      <itemizedlist>
        <listitem><para><emphasis>Reference Counting</emphasis> -
        Implement proper reference counting in the rowsource handler
        functions.</para></listitem>
        <listitem><para><emphasis>Reset Handlers</emphasis> - Provide
        reset handlers when possible to avoid row caching
        overhead.</para></listitem>
        <listitem><para><emphasis>Row Ownership</emphasis> - Follow
        consumption semantics where functions that take row
        parameters assume ownership.</para></listitem>
        <listitem><para><emphasis>Cleanup Handlers</emphasis> -
        Implement finish handlers to properly release all
        resources.</para></listitem>
      </itemizedlist>

      <para>Following these patterns ensures that custom rowsources
      integrate properly with the query engine's memory management
      system and don't introduce memory leaks or corruption.</para>

    </section>

  </section>

  <section id="best-practices">
    <title>Best Practices for Memory Management</title>

    <para>Here are some best practices for memory mamnagement in Rasqal:</para>

    <section id="rowsource-implementation-best-practices">
      <title>Rowsource Implementation</title>

      <itemizedlist>
        <listitem><para><emphasis>Always Implement Reset
	Handlers</emphasis> - Provide reset handlers whenever
	possible to avoid the SAVE_ROWS flag and associated memory
	overhead.</para></listitem>

        <listitem><para><emphasis>Follow Consumption
	Semantics</emphasis> - When functions consume parameters,
	document this clearly and set consumed pointers to NULL to
	prevent double-free.</para></listitem>

        <listitem><para><emphasis>Validate Reference
	Counts</emphasis> - Use debug builds to validate that
	reference counts behave as expected.</para></listitem>

        <listitem><para><emphasis>Test with Memory
	Debugging</emphasis> - Always test rowsource implementations
	with AddressSanitizer or similar tools.</para></listitem>

      </itemizedlist>

    </section>

    <section id="debugging-memory-issues">
      <title>Debugging Memory Issues</title>

      <itemizedlist>
        <listitem><para><emphasis>Use AddressSanitizer</emphasis> -
	Enable AddressSanitizer leak detection for comprehensive
	memory issue detection.</para></listitem>

        <listitem><para><emphasis>Enable Debug Logging</emphasis> -
	Use debug builds with reference count logging to trace object
	lifecycles.</para></listitem>

        <listitem><para><emphasis>Test Edge Cases</emphasis> - Pay
	special attention to empty patterns, optional joins, and
	other complex query structures.</para></listitem>

        <listitem><para><emphasis>Validate Cleanup</emphasis> -
	Ensure all objects reach zero reference count and are
	properly freed.</para></listitem>

      </itemizedlist>

    </section>

  </section>

  <section id="execution-class-relationships">
    <title>Execution Class Relationships and Interactions</title>

    <para>This section documents the relationships between the major query engine
    execution classes, their ownership patterns, and interaction mechanisms. Understanding
    these relationships is crucial for developers working with Rasqal internals,
    implementing extensions, or debugging execution issues.</para>

    <section id="class-hierarchy-overview">
      <title>Class Hierarchy Overview</title>

      <para>The Rasqal query engine execution architecture centers around six major
      classes that work together to process SPARQL queries:</para>

      <programlisting>
Query Execution Class Hierarchy and Relationships

                    rasqal_query (Central Orchestrator)
                         |
        ┌────────────────┼─────────────────────┐
        │                │                     │
rasqal_query_scope   rasqal_graph_pattern   Execution Pipeline
   (Scoping)          (Structure)              │
        │                │                     │
        │                │               rasqal_rowsource
        │                │              (Iterator Execution)
        │                │                     │
        │                │               rasqal_row
        │                │              (Result Container)
        │                │                     │
        └────────────────┼─────────────────────┘
                         │
                 rasqal_expression
                 (Expression Evaluation)
      </programlisting>

    </section>

    <section id="ownership-relationships">
      <title>Ownership Relationships</title>

      <para>The ownership model follows strict hierarchical patterns with clear
      responsibilities for memory management:</para>

      <programlisting>
Ownership Hierarchy (OWNS relationship):

rasqal_query (ROOT OWNER)
├── OWNS graph_patterns → rasqal_graph_pattern objects
│   ├── OWNS triples → rasqal_triple objects
│   ├── OWNS filter_expression → rasqal_expression objects
│   ├── OWNS graph_patterns → nested rasqal_graph_pattern objects
│   └── REFERS execution_scope → rasqal_query_scope (borrowed reference)
├── OWNS root_scope → rasqal_query_scope objects
│   ├── OWNS owned_triples → rasqal_triple objects (scope-isolated)
│   ├── OWNS local_vars → rasqal_variables_table
│   └── OWNS child_scopes → nested rasqal_query_scope objects
├── OWNS variables_table → rasqal_variables_table (global)
└── OWNS query_results → rasqal_query_results objects

Execution Context Ownership:

rasqal_rowsource (Execution Owner)
├── OWNS variables_sequence → rasqal_variable* references
├── OWNS vars_table → rasqal_variables_table (local copy)
├── OWNS rows_sequence → rasqal_row objects (when caching)
├── OWNS user_data → specialized context structures
└── REFERS query → rasqal_query (borrowed reference)

rasqal_row (Result Owner)
├── OWNS values → rasqal_literal* array
├── OWNS order_values → rasqal_literal* array (for ORDER BY)
└── REFERS rowsource → rasqal_rowsource (producing rowsource)
      </programlisting>

      <variablelist>
        <varlistentry>
          <term>Primary Ownership (OWNS)</term>
          <listitem><para>The owner is responsible for freeing the owned object.
          Transfer of ownership typically occurs through sequence insertion with
          appropriate free handlers.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Reference Relationships (REFERS)</term>
          <listitem><para>Borrowed references that must remain valid for the
          lifetime of the referring object. No cleanup responsibility.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Conditional Ownership</term>
          <listitem><para>Some objects (like triples in graph patterns) may be
          owned conditionally based on flags like <literal>owns_triples</literal>.</para></listitem>
        </varlistentry>
      </variablelist>

    </section>

    <section id="usage-relationships">
      <title>Usage and Interaction Patterns</title>

      <para>The execution classes interact through well-defined usage patterns
      that respect the ownership model:</para>

      <programlisting>
Usage Relationships (USES relationship):

rasqal_query
├── USES rasqal_graph_pattern (hierarchy traversal during execution)
├── USES rasqal_query_scope (variable resolution and scoping)
├── USES rasqal_rowsource (query execution via rasqal_query_execute())
└── USES rasqal_expression (evaluation in various contexts)

rasqal_rowsource (Iterator Composition)
├── USES rasqal_query (execution context, variable tables)
├── USES rasqal_row (produces and consumes during iteration)
├── USES rasqal_query_scope (scope-aware variable resolution)
├── USES other rasqal_rowsource (composition - filter, join, union)
└── USES rasqal_expression (filter conditions, join predicates)

rasqal_expression (Evaluation Context)
├── USES rasqal_query_scope (scope-aware variable resolution)
├── USES rasqal_evaluation_context (runtime evaluation environment)
├── USES rasqal_row (current variable bindings during evaluation)
└── USES nested rasqal_expression (recursive evaluation)

rasqal_graph_pattern (Structural Relationships)
├── USES rasqal_query_scope (execution scope assignment)
├── USES rasqal_expression (filter expressions)
├── USES rasqal_triple (basic graph patterns)
└── USES nested rasqal_graph_pattern (complex pattern structures)
      </programlisting>

    </section>

    <section id="reference-counting-patterns">
      <title>Reference Counting and Memory Management</title>

      <para>Most execution classes use reference counting for safe memory management
      with specific patterns for different object types:</para>

      <variablelist>
        <varlistentry>
          <term>rasqal_rowsource Reference Counting</term>
          <listitem><para>Uses <literal>usage</literal> field for reference counting.
          Ownership transfer semantics apply - functions that consume rowsource
          parameters take ownership and are responsible for cleanup. Found in
          <filename>src/rasqal_rowsource.c:84</filename>.</para></listitem>
        </varlistentry>

        <varlistentry>
          <term>rasqal_row Reference Counting</term>
          <listitem><para>Reference counted with back-reference to producing rowsource.
          Follows caller ownership - functions returning rows transfer ownership to
          the caller. Found in <filename>src/rasqal_internal.h</filename> around line 1180.</para></listitem>
        </varlistentry>

        <varlistentry>
          <term>rasqal_query_scope Reference Counting</term>
          <listitem><para>Reference counted with parent-child hierarchy management.
          Parent scopes own child scopes, but child scopes hold borrowed references
          to parents. Found in <filename>src/rasqal_query_scope.c:96</filename>.</para></listitem>
        </varlistentry>

        <varlistentry>
          <term>Consumption Semantics</term>
          <listitem><para>Functions like join operations consume input rows and
          take ownership, preventing double-free conditions. This pattern is used
          throughout rowsource implementations.</para></listitem>
        </varlistentry>
      </variablelist>

    </section>

    <section id="scope-integration-patterns">
      <title>Scope Integration in Execution Classes</title>

      <para>The SPARQL 1.1 scope system integrates across all execution classes
      to ensure proper variable isolation and inheritance:</para>

      <itemizedlist>
        <listitem><para><emphasis>Graph Pattern Scope Assignment</emphasis> -
        Each <literal>rasqal_graph_pattern</literal> maintains an
        <literal>execution_scope</literal> reference that determines its variable
        scoping context during execution.</para></listitem>

        <listitem><para><emphasis>Rowsource Scope Awareness</emphasis> -
        Filter rowsources maintain <literal>evaluation_scope</literal> for proper
        variable scoping (found in <filename>src/rasqal_rowsource_filter.c:62</filename>).
        This ensures filter expressions respect SPARQL 1.1 scoping rules.</para></listitem>

        <listitem><para><emphasis>Expression Scope Context</emphasis> -
        Expression evaluation uses <literal>rasqal_variable_lookup_context</literal>
        to traverse scope hierarchies for variable resolution, ensuring proper
        inheritance and isolation.</para></listitem>

        <listitem><para><emphasis>Variable Resolution Integration</emphasis> -
        The scope-aware variable resolution system (documented in
        <filename>src/rasqal_internal.h:415-432</filename>) provides consistent
        variable lookup across all execution contexts.</para></listitem>
      </itemizedlist>

    </section>

    <section id="iterator-composition-architecture">
      <title>Iterator Composition Architecture</title>

      <para>Rowsources compose through delegation to create execution trees that
      mirror the algebraic query structure:</para>

      <programlisting>
Iterator Composition Examples:

Filter Rowsource (rasqal_rowsource_filter.c):
  context.rowsource → inner rasqal_rowsource (data source)
  context.expr → rasqal_expression (filter condition)
  context.evaluation_scope → rasqal_query_scope (variable context)

Join Rowsource (rasqal_rowsource_join.c):
  context.left → rasqal_rowsource (left input stream)
  context.right → rasqal_rowsource (right input stream)
  context.expr → rasqal_expression (join condition, optional)
  context.rc_map → rasqal_row_compatible (compatibility checking)

Union Rowsource:
  context.left → rasqal_rowsource (first alternative)
  context.right → rasqal_rowsource (second alternative)
      </programlisting>

      <para>This composition pattern enables:</para>
      <itemizedlist>
        <listitem><para><emphasis>Lazy Evaluation</emphasis> - Each rowsource
        produces results on demand, enabling memory-efficient processing of
        large result sets.</para></listitem>

        <listitem><para><emphasis>Early Termination</emphasis> - LIMIT clauses
        can stop processing as soon as sufficient results are produced.</para></listitem>

        <listitem><para><emphasis>Streaming Results</emphasis> - Results can be
        consumed as they are produced, enabling interactive applications.</para></listitem>

        <listitem><para><emphasis>Algebraic Transparency</emphasis> - The rowsource
        composition directly mirrors the algebraic structure, making optimization
        and debugging easier.</para></listitem>
      </itemizedlist>

    </section>

    <section id="execution-lifecycle-integration">
      <title>Execution Lifecycle Integration</title>

      <para>The execution classes work together through a coordinated lifecycle:</para>

      <orderedlist>
        <listitem><para><emphasis>Query Construction</emphasis> -
        <literal>rasqal_query</literal> owns the complete query structure including
        graph patterns, scopes, and variable tables.</para></listitem>

        <listitem><para><emphasis>Scope Hierarchy Building</emphasis> -
        <literal>rasqal_query_scope</literal> objects are created during parsing
        and transformation to establish variable isolation boundaries.</para></listitem>

        <listitem><para><emphasis>Execution Tree Construction</emphasis> -
        <literal>rasqal_rowsource</literal> objects are composed into execution
        trees that mirror the algebraic structure.</para></listitem>

        <listitem><para><emphasis>Iterator Execution</emphasis> -
        <literal>rasqal_row</literal> objects flow through the execution tree
        carrying variable bindings between rowsources.</para></listitem>

        <listitem><para><emphasis>Expression Evaluation</emphasis> -
        <literal>rasqal_expression</literal> objects evaluate conditions and
        computations within the proper scope context.</para></listitem>

        <listitem><para><emphasis>Result Collection</emphasis> - Final results
        are collected and formatted for output while maintaining proper object
        lifecycle management.</para></listitem>
      </orderedlist>

    </section>

    <section id="debugging-class-interactions">
      <title>Debugging Class Interactions</title>

      <para>When debugging issues in the query engine execution, understanding
      these class relationships helps identify common problems:</para>

      <variablelist>
        <varlistentry>
          <term>Memory Management Issues</term>
          <listitem><para>Check reference counting patterns, ownership transfer
          points, and consumption semantics. Use AddressSanitizer to detect
          leaks and use-after-free conditions.</para></listitem>
        </varlistentry>

        <varlistentry>
          <term>Variable Scoping Problems</term>
          <listitem><para>Verify that <literal>execution_scope</literal> references
          are properly set on graph patterns and that rowsources use scope-aware
          variable resolution.</para></listitem>
        </varlistentry>

        <varlistentry>
          <term>Execution Pipeline Issues</term>
          <listitem><para>Trace rowsource composition and verify that each rowsource
          properly implements the iterator interface with correct row ownership
          patterns.</para></listitem>
        </varlistentry>

        <varlistentry>
          <term>Expression Evaluation Problems</term>
          <listitem><para>Ensure expression evaluation contexts include proper
          scope information and that variable lookups respect scope boundaries.</para></listitem>
        </varlistentry>
      </variablelist>

    </section>

  </section>

</chapter>
