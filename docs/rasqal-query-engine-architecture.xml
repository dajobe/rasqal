<?xml version="1.0" encoding="UTF-8"?>
<chapter id="query-engine-architecture">
  <title>Rasqal Query Engine Architecture</title>

  <para>This chapter provides a comprehensive overview of the Rasqal
  RDF query engine architecture, covering the complete query
  execution pipeline, variable binding mechanisms, and architectural
  patterns that developers need to understand when working with
  Rasqal internals.</para>

  <section id="query-engine-overview">
    <title>Overview</title>

    <para>Rasqal follows a classic compiler architecture with
    distinct phases that transform SPARQL queries from text to
    results. The query engine implements a four-phase pipeline:
    parsing, transformation, algebra generation, and rowsource
    execution. Each phase has specific responsibilities and
    architectural patterns that enable efficient query processing and
    extensibility.</para>

    <para>The architecture is designed to support multiple query
    languages (SPARQL, RDQL) while maintaining a unified internal
    representation through the algebra system. This design enables
    query optimization, execution planning, and efficient processing
    of complex graph patterns and expressions.</para>

    <para>The architecture provides a robust foundation for RDF query
    processing with clear separation of concerns, extensible design,
    and efficient execution patterns. Understanding these
    architectural patterns is essential for developers working with
    Rasqal internals, implementing custom extensions, or optimizing
    query performance.</para>

  </section>

  <section id="memory-ownership">
    <title>Memory Ownership and Cleanup</title>

    <para>This section summarizes the ownership model used across the query engine. Correct ownership is critical for avoiding leaks and double frees during both normal execution and error paths.</para>

    <section id="ownership-principles">
      <title>Core Principles</title>
      <itemizedlist>
        <listitem><para>Use <literal>raptor_sequence</literal> with appropriate free handlers whenever a sequence owns allocated objects.</para></listitem>
        <listitem><para>Transfer ownership exactly once; after pushing objects into an owning sequence, do not free them manually.</para></listitem>
        <listitem><para>On error paths, free either the sequence (if it owns items) or the individual items (if ownership was not transferred).</para></listitem>
      </itemizedlist>
    </section>

    <section id="ownership-graph-patterns">
      <title>Graph Patterns and Scopes</title>
      <para>The main query owns graph patterns and maintains a hierarchy of graph pattern scopes for SPARQL 1.1 semantic isolation.</para>
      <programlisting>
rasqal_query
├── graph_patterns (raptor_sequence)     // Pattern structure hierarchy
│   └── rasqal_graph_pattern objects
│       └── execution_scope (reference)  // Points to appropriate scope
└── root_scope (rasqal_query_scope)      // Root scope with children
    ├── owned_triples (raptor_sequence)      // Triples owned by this scope
    ├── local_vars (rasqal_variables_table)  // Local variables
    └── child_scopes (raptor_sequence)       // Nested scopes
        └── rasqal_query_scope objects
      </programlisting>
      <itemizedlist>
        <listitem><para><emphasis>Pattern Owner:</emphasis> <literal>rasqal_query</literal> owns the pattern structure hierarchy.</para></listitem>
        <listitem><para><emphasis>Scope Owner:</emphasis> <literal>rasqal_query</literal> owns the root scope, which owns child scopes.</para></listitem>
        <listitem><para><emphasis>Triple Owner:</emphasis> Each scope exclusively owns its triples, preventing contamination.</para></listitem>
        <listitem><para><emphasis>Cleanup:</emphasis> Patterns and scopes are freed when the query is freed via proper reference counting.</para></listitem>
      </itemizedlist>
    </section>

    <section id="ownership-exists-expressions">
      <title>EXISTS / NOT EXISTS Expressions</title>
      <para>For EXISTS expressions, the expression frees only the sequence container; the sequence free handler must free the contained graph patterns.</para>
      <programlisting>
/* Inside expression cleanup */
case RASQAL_EXPR_EXISTS:
case RASQAL_EXPR_NOT_EXISTS:
  raptor_free_sequence(e-&gt;args);  /* sequence frees contents via handler */
  break;
      </programlisting>
      <para>When constructing such expressions, create the sequence with an appropriate free handler and transfer ownership before attaching it to the expression.</para>
    </section>

    <section id="ownership-results">
      <title>Query Results</title>
      <para>Avoid creating dummy queries when constructing results from strings. Use a NULL query; results cleanup paths already handle this.</para>
      <programlisting>
/* Correct */
results = rasqal_new_query_results2(world, NULL, type);
      </programlisting>
    </section>

    <section id="ownership-sequences">
      <title>Sequences and Free Handlers</title>
      <para>Create sequences with free handlers whenever the sequence is the owner of its elements.</para>
      <programlisting>
/* Graph patterns */
raptor_new_sequence((raptor_data_free_handler)rasqal_free_graph_pattern,
                    (raptor_data_print_handler)rasqal_graph_pattern_print);

/* Rows */
raptor_new_sequence((raptor_data_free_handler)rasqal_free_row,
                    (raptor_data_print_handler)rasqal_row_print);

/* Statements (triples) */
raptor_new_sequence((raptor_data_free_handler)raptor_free_statement,
                    (raptor_data_print_handler)raptor_statement_print);
      </programlisting>
    </section>

    <section id="ownership-error-paths">
      <title>Error Path Cleanup</title>
      <para>Choose cleanup based on whether ownership was transferred.</para>
      <programlisting>
if(sequence_created) {
  if(object_creation_failed)
    raptor_free_sequence(seq);   /* seq owns and frees items */
} else {
  rasqal_free_object(obj);       /* no transfer, free directly */
}
      </programlisting>
    </section>

    <section id="ownership-pitfalls">
      <title>Common Pitfalls</title>
      <itemizedlist>
        <listitem><para>Creating sequences without free handlers for owned items.</para></listitem>
        <listitem><para>Double-freeing items after transferring ownership to a sequence.</para></listitem>
        <listitem><para>Missing error-path cleanup that matches ownership transfer.</para></listitem>
        <listitem><para>Creating dummy objects (e.g., temporary queries) without proper lifecycle management.</para></listitem>
      </itemizedlist>
    </section>

  </section>

  <section id="query-execution-pipeline">
    <title>Query Execution Pipeline</title>

    <para>The Rasqal query execution pipeline consists of four main
    phases that transform SPARQL queries from text to results:</para>

    <section id="parsing-phase">
      <title>Parsing Phase</title>

      <para>The parsing phase takes SPARQL query text and produces an
      Abstract Syntax Tree (AST) in the
      <literal>rasqal_query</literal> structure. This phase handles
      lexical analysis, syntax analysis, and AST construction through
      the <filename>sparql_parser.y</filename> and
      <filename>sparql_lexer.l</filename> files.</para>

      <para>During parsing, the system:</para>
      <itemizedlist>
        <listitem><para>Performs lexical analysis to identify tokens and keywords</para></listitem>
        <listitem><para>Constructs syntax trees for graph patterns, expressions, and variable declarations</para></listitem>
        <listitem><para>Registers variables and establishes initial scoping</para></listitem>
        <listitem><para>Validates basic syntax and semantic constraints</para></listitem>
      </itemizedlist>

    </section>

    <section id="transformation-phase">
      <title>Transformation Phase</title>

      <para>The query transformation phase takes the raw AST from the
      parser and produces a validated and transformed query
      structure. This phase performs variable analysis, type
      checking, and optimization preparation through
      <filename>rasqal_query_transform.c</filename>.</para>

      <para>Key transformation activities include:</para>
      <itemizedlist>
        <listitem><para>Variable scope analysis and binding validation</para></listitem>
        <listitem><para>Type checking for expressions and literals</para></listitem>
        <listitem><para>Constant folding and expression simplification</para></listitem>
        <listitem><para>Preparation for algebra generation</para></listitem>
      </itemizedlist>

    </section>

    <section id="algebra-generation-phase">
      <title>Algebra Generation Phase</title>

      <para>The algebra generation phase converts the transformed
      query into a relational algebra representation, mapping graph
      patterns to algebra operator trees. This phase creates the
      foundation for query optimization and execution
      planning.</para>

      <para>The algebra system provides:</para>
      <itemizedlist>
        <listitem><para>Unified representation for different query languages</para></listitem>
        <listitem><para>Foundation for query optimization</para></listitem>
        <listitem><para>Execution planning capabilities</para></listitem>
        <listitem><para>Extensibility for new query features</para></listitem>
      </itemizedlist>

    </section>

    <section id="rowsource-execution-phase">
      <title>Rowsource Execution Phase</title>

      <para>The rowsource execution phase takes algebra operators and
      produces query results through iterator-based execution with
      lazy evaluation. This phase implements the actual data access
      and result generation.</para>

      <para>Execution characteristics include:</para>
      <itemizedlist>
        <listitem><para>Lazy evaluation for memory efficiency</para></listitem>
        <listitem><para>Iterator-based processing for large result sets</para></listitem>
        <listitem><para>Early termination support for LIMIT clauses</para></listitem>
        <listitem><para>Streaming results for interactive applications</para></listitem>
      </itemizedlist>

    </section>

  </section>

  <section id="parser-architecture">
    <title>Parser Architecture</title>

    <para>The SPARQL parser is implemented using Bison (yacc) with
    grammar rules that create AST nodes during parsing. Parser
    actions create various structures including graph patterns,
    expressions, variable registrations, and scope hierarchies for
    SPARQL 1.1 compliance.</para>

    <para>Variables are registered during parsing through
    <function>rasqal_query_add_variable</function>, which creates
    variables from literals and adds them to appropriate scopes
    within the variable scope hierarchy. The hierarchical scope system
    ensures proper SPARQL 1.1 variable isolation and inheritance.</para>

    <section id="scope-creation-during-parsing">
      <title>Scope Creation During Parsing</title>

      <para>The parser creates scope hierarchies as it encounters
      different graph pattern operators:</para>

      <itemizedlist>
        <listitem><para><emphasis>Root Scope Creation</emphasis> - The parser creates a root scope for the main query to contain outer query triples and variables</para></listitem>
        <listitem><para><emphasis>EXISTS Scope Creation</emphasis> - EXISTS/NOT EXISTS patterns trigger creation of isolated child scopes with proper parent references for variable inheritance</para></listitem>
        <listitem><para><emphasis>Triple Assignment</emphasis> - Triples are assigned to their appropriate scope during parsing, preventing later contamination</para></listitem>
        <listitem><para><emphasis>Scope Assignment</emphasis> - Graph patterns receive references to their evaluation scopes, establishing the pattern-scope relationship</para></listitem>
      </itemizedlist>

      <para>This scope creation during parsing ensures semantic isolation
      is established from the beginning of query processing, eliminating
      the need for runtime decontamination.</para>
    </section>

    <para>The modern parser architecture supports both traditional SPARQL 1.0
    patterns and SPARQL 1.1 scoped patterns through the unified scope
    management system, providing backwards compatibility while enabling
    advanced semantic features.</para>

  </section>

  <section id="algebra-system">
    <title>Algebra System</title>

    <para>Rasqal represents graph patterns as a hierarchy with
    various operator types including basic patterns, optional
    patterns, union patterns, group patterns, graph patterns, filter
    patterns, and others. Each pattern type has specific semantics
    and evaluation requirements.</para>

    <para>Basic graph patterns consist of triple patterns, which are
    the fundamental building blocks containing subject, predicate,
    object, and optional named graph context.</para>

    <para>The algebra system provides the foundation for query
    optimization and execution planning, with each operator type
    having specific performance characteristics and optimization
    opportunities.</para>

    <section id="algebra-operators">
      <title>Algebra Operators</title>

      <para>The algebra system supports the following operator types:</para>

      <variablelist>
        <varlistentry>
          <term>Basic Graph Patterns</term>
          <listitem><para>Triple patterns that form the fundamental data access units</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Optional Patterns</term>
          <listitem><para>Left outer join semantics for optional data matching</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Union Patterns</term>
          <listitem><para>Disjunctive combination of multiple graph patterns</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Group Patterns</term>
          <listitem><para>Conjunctive combination of multiple graph patterns</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Graph Patterns</term>
          <listitem><para>Named graph context for pattern evaluation</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Filter Patterns</term>
          <listitem><para>Expression-based filtering of pattern results</para></listitem>
        </varlistentry>
      </variablelist>

    </section>

  </section>

  <section id="rowsource-architecture">
    <title>Rowsource Architecture</title>

    <para>Rasqal uses the iterator pattern for query execution, with
    rowsources implementing <function>read_row</function>,
    <function>finished</function>, and <function>reset</function>
    methods. This architecture enables lazy evaluation, memory
    efficiency for large result sets, early termination for LIMIT
    clauses, and streaming results.</para>

    <para>The execution flow follows a bottom-up approach, generating
    rows from basic graph patterns and processing them through
    operators like JOIN, OPTIONAL, and FILTER before collecting
    results at the top level.</para>

    <para>The rowsource architecture provides excellent extensibility
    for new algebra operators through specialized rowsource
    implementations.</para>

    <section id="rowsource-lifecycle-management">
      <title>Rowsource Lifecycle Management</title>

      <para>Rowsources use reference counting for memory management,
      with each rowsource maintaining a usage count that tracks how
      many references exist to the rowsource. This enables safe
      sharing of rowsources between different parts of the query
      execution pipeline while ensuring proper cleanup when
      rowsources are no longer needed.</para>

      <para>The lifecycle management system implements several key principles:</para>

      <itemizedlist>
        <listitem><para><emphasis>Reference Counting</emphasis> - Each rowsource has a usage counter that is incremented when new references are created and decremented when references are released</para></listitem>
        <listitem><para><emphasis>Ownership Transfer</emphasis> - Functions that consume rowsource parameters take ownership and are responsible for cleanup</para></listitem>
        <listitem><para><emphasis>Reset Capabilities</emphasis> - Rowsources that support reset operations can be reused without requiring row caching, improving memory efficiency</para></listitem>
        <listitem><para><emphasis>Automatic Row Saving</emphasis> - Rowsources without reset handlers automatically save rows to support multiple iterations</para></listitem>
      </itemizedlist>

      <para>The reference counting system prevents memory leaks by
      ensuring that rowsources are freed when their usage count
      reaches zero. Special care is taken to avoid circular
      references between rows and rowsources, which could prevent
      proper cleanup.</para>

    </section>

    <section id="row-ownership-patterns">
      <title>Row Ownership and Memory Management</title>

      <para>Rows returned from rowsources follow specific ownership
      patterns to ensure proper memory management throughout the
      query execution pipeline. Each row maintains its own reference
      count and holds a reference to its originating
      rowsource.</para>

      <para>Key ownership principles include:</para>

      <itemizedlist>
        <listitem><para><emphasis>Caller Ownership</emphasis> -
        Functions that return rows transfer ownership to the caller,
        who becomes responsible for freeing the row</para></listitem>

        <listitem><para><emphasis>Row Reference to
	Rowsource</emphasis> - Each row holds a reference to its
	originating rowsource, ensuring the rowsource remains valid
	while the row exists</para></listitem>

        <listitem><para><emphasis>Consumption Semantics</emphasis> -
	Functions that consume rows (such as join merge operations)
	take ownership and free the consumed rows
	internally</para></listitem>

        <listitem><para><emphasis>Copy-on-Reference</emphasis> - When
	multiple references to a row are needed, the row's reference
	count is incremented rather than copying the entire row
	structure</para></listitem>

      </itemizedlist>

      <para>This ownership model ensures efficient memory usage while
      preventing both memory leaks and use-after-free conditions. The
      reference counting system automatically handles cleanup when
      objects are no longer referenced.</para>

    </section>

    <section id="rowsource-scope-integration">
      <title>Rowsource Scope Integration</title>

      <para>All rowsources now use scope-aware variable resolution to ensure proper
      variable scoping throughout the query execution pipeline.</para>

      <section id="filter-rowsource-scoping">
        <title>Filter Rowsource Scope Integration</title>

        <para>The filter rowsource uses scope-aware variable resolution to ensure
        that filter expressions respect proper variable scoping boundaries. When
        evaluating filter expressions, the rowsource creates a scope-aware lookup
        context that includes the current execution scope and appropriate search
        flags for variable inheritance.</para>

        <para>This ensures that variables referenced in filter expressions are
        resolved according to SPARQL 1.1 scoping rules, preventing access to
        out-of-scope variables and maintaining proper semantic isolation.</para>
      </section>
    </section>

    <section id="rowsource-types">
      <title>Rowsource Types</title>

      <para>The rowsource system includes several specialized types:</para>

      <variablelist>
        <varlistentry>
          <term>Triples Pattern Rowsource</term>
          <listitem><para>Handles basic graph pattern execution and triple matching</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Filter Rowsource</term>
          <listitem><para>Applies filter expressions to rows from other rowsources with scope-aware variable resolution</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Join Rowsource</term>
          <listitem><para>Implements join operations between multiple rowsources with proper row consumption semantics</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Optional Rowsource</term>
          <listitem><para>Implements left outer join semantics for optional patterns</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Union Rowsource</term>
          <listitem><para>Combines results from multiple rowsources</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Project Rowsource</term>
          <listitem><para>Selects and reorders variables in result rows</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Empty Rowsource</term>
          <listitem><para>Produces exactly one empty row for empty optional patterns and other degenerate cases, with reset capability to avoid row caching</para></listitem>
        </varlistentry>
      </variablelist>

    </section>

  </section>

  <section id="minus-semantics-and-internals">
    <title>MINUS Semantics and Internals</title>

    <para>This section documents the MINUS implementation and supporting internals validated during work on SPARQL 1.1 negation tests.</para>

    <section id="minus-compatibility">
      <title>Compatibility via Domain Intersection</title>
      <para>Rasqal implements MINUS compatibility according to SPARQL 1.1 domain-intersection semantics:</para>
      <itemizedlist>
        <listitem><para>Only variables bound on both sides (LHS and RHS) are considered shared.</para></listitem>
        <listitem><para>For shared variables, term equality is required for compatibility.</para></listitem>
        <listitem><para>If no compatible RHS row exists, the LHS row is emitted.</para></listitem>
      </itemizedlist>
      <para>Term equality is evaluated with <function>rasqal_literal_equals_flags</function>.</para>
    </section>

    <section id="minus-rowsource-lifecycle">
      <title>Rowsource Lifecycle and Row Ownership</title>
      <para>Rows returned from MINUS must carry a valid <literal>rowsource</literal> pointer for correct deep-copy behavior. When emitting an LHS row:</para>
      <itemizedlist>
        <listitem><para>Set the row's <literal>rowsource</literal> to the MINUS rowsource if not already set.</para></listitem>
        <listitem><para>Create a deep copy with <function>rasqal_new_row_from_row_deep</function>.</para></listitem>
        <listitem><para>Attach the new row to the MINUS rowsource and propagate the row offset.</para></listitem>
      </itemizedlist>
      <para>This avoids a null <literal>row-&gt;rowsource</literal> dereference during deep copy.</para>
    </section>

    <section id="filter-ebv-and-unbound">
      <title>FILTER EBV and Unbound Operands</title>
      <para>FILTER comparison operators (EQ, NEQ, LT, GT, LE, GE) treat unbound operands as FALSE, filtering the solution rather than raising errors, per SPARQL 1.1. This is implemented in <filename>rasqal_expr_evaluate.c</filename>.</para>
    </section>

    <section id="exists-variable-usage">
      <title>EXISTS/NOT EXISTS Variable Usage Analysis</title>
      <para>Variables referenced solely inside EXISTS/NOT EXISTS must not trigger "not bound and not used" errors at transform time. The transformer supports detection in both FILTER expressions and EXISTS-local BGPs. This analysis is performed in <filename>rasqal_query_transform.c</filename> and is limited to variable mention detection; it does not evaluate sub-queries.</para>
    </section>
  </section>

  <section id="variable-scoping-and-rows">
    <title>Variable Scoping, Rows, and Headers</title>

    <para>Result rows carry values and a back-pointer to the producing rowsource. The rowsource header defines variable ordering for row printing and projection. Key rules:</para>
    <itemizedlist>
      <listitem><para>Always attach emitted rows to the producing rowsource via <function>rasqal_row_set_rowsource</function>.</para></listitem>
      <listitem><para>Preserve <literal>offset</literal> when creating derived rows to maintain stable ordering.</para></listitem>
      <listitem><para>Use <function>rasqal_rowsource_get_variable_by_offset</function> for header-based name lookup when printing rows.</para></listitem>
    </itemizedlist>
  </section>

  <section id="expression-evaluation-system">
    <title>Expression Evaluation System</title>

    <para>Rasqal supports various expression types including
    literals, functions, variables, logical operators, comparison
    operators, and specialized operators. Each expression type has
    specific evaluation semantics and requirements.</para>

    <para>Expressions are evaluated within a
    <literal>rasqal_evaluation_context</literal> that provides access
    to the world, query, flags, comparison flags, and current row
    bindings. The expression evaluation system has been enhanced with
    scope-aware variable resolution to support proper SPARQL 1.1
    variable scoping semantics.</para>

    <para>The scope-aware expression evaluation system ensures that
    variable lookups during expression evaluation respect the proper
    scope boundaries and inheritance rules, enabling complex SPARQL 1.1
    features like nested EXISTS patterns and variable isolation.</para>

    <section id="expression-types">
      <title>Expression Types</title>

      <para>The expression system supports the following types:</para>

      <variablelist>
        <varlistentry>
          <term>Literals</term>
          <listitem><para>Constant values including strings, numbers, booleans, and URIs</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Variables</term>
          <listitem><para>Variable references that resolve to current bindings</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Functions</term>
          <listitem><para>Built-in and user-defined function calls</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Logical Operators</term>
          <listitem><para>AND, OR, NOT operations on boolean expressions</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Comparison Operators</term>
          <listitem><para>Equality, inequality, and ordering comparisons</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Arithmetic Operators</term>
          <listitem><para>Mathematical operations on numeric expressions</para></listitem>
        </varlistentry>
      </variablelist>

    </section>

  </section>

  <section id="variable-binding-system">
    <title>Variable Binding System</title>

    <para>The variable binding system includes a query scope
    architecture that ensures proper SPARQL 1.1 variable isolation and inheritance
    semantics. </para>

    <section id="query-scope-architecture">
      <title>Query Scope Architecture</title>

      <para>The query scope architecture implements hierarchical scope management
      to ensure proper SPARQL 1.1 variable isolation and inheritance semantics.
      Each query pattern operator creates an isolated scope with its own triple
      ownership and variable visibility rules.</para>

      <para><emphasis>Scope Types Supported:</emphasis></para>
      <itemizedlist>
        <listitem><para><literal>ROOT</literal> - Main query scope for outer query patterns</para></listitem>
        <listitem><para><literal>EXISTS</literal> - EXISTS pattern scope with variable inheritance</para></listitem>
        <listitem><para><literal>NOT_EXISTS</literal> - NOT EXISTS pattern scope for negation</para></listitem>
        <listitem><para><literal>MINUS</literal> - MINUS pattern scope for set difference</para></listitem>
        <listitem><para><literal>UNION</literal> - UNION pattern scope for disjunctive patterns</para></listitem>
        <listitem><para><literal>SUBQUERY</literal> - Subquery scope with complete isolation</para></listitem>
        <listitem><para><literal>GROUP</literal> - Nested group pattern scope for isolation</para></listitem>
      </itemizedlist>
    </section>

    <section id="scope-aware-variable-resolution">
      <title>Scope-Aware Variable Resolution</title>

      <para>The variable resolution system uses hierarchical scope-aware lookup
      that respects SPARQL 1.1 semantic boundaries. Variables are resolved
      through a scope hierarchy with proper inheritance and isolation rules.</para>

      <para><emphasis>Resolution Algorithm:</emphasis></para>
      <orderedlist>
        <listitem><para>Start with current execution scope</para></listitem>
        <listitem><para>Search local variables in current scope</para></listitem>
        <listitem><para>If not found and inheritance allowed, search parent scope</para></listitem>
        <listitem><para>Continue up hierarchy until root scope</para></listitem>
        <listitem><para>Return first match with proper precedence rules</para></listitem>
      </orderedlist>

      <para>This ensures that variable lookups respect SPARQL 1.1 scoping
      requirements while maintaining efficient resolution performance.</para>
    </section>

    <section id="variable-lifecycle">
      <title>Variable Lifecycle</title>

      <para>Variables follow a specific lifecycle through the query
      execution process:</para>

      <orderedlist>
        <listitem><para><emphasis>Registration</emphasis> - Variables
	are registered during parsing and added to the query's
	variable table</para></listitem>

        <listitem><para><emphasis>Analysis</emphasis> - The query
	transformer analyzes variable usage and binding
	patterns</para></listitem>

        <listitem><para><emphasis>Binding</emphasis> - Variables
	receive values during query execution</para></listitem>

        <listitem><para><emphasis>Propagation</emphasis> - Variable
	bindings are propagated to sub-queries and
	expressions</para></listitem>

        <listitem><para><emphasis>Cleanup</emphasis> - Variable
	bindings are cleaned up after query
	completion</para></listitem>

      </orderedlist>

    </section>

    <section id="variable-access-patterns">
      <title>Variable Access Patterns</title>

      <para>Rasqal provides multiple patterns for accessing variable bindings
      with scope awareness:</para>

      <variablelist>
        <varlistentry>
          <term>Expression Context Access</term>
          <listitem><para>Uses
	  <function>rasqal_literal_value</function> during expression
	  evaluation within an active evaluation context, with scope-aware
	  variable resolution</para></listitem>

        </varlistentry>
        <varlistentry>
          <term>Scope-Aware Variable Lookup</term>
          <listitem><para>Uses scope-aware variable resolution functions
          for hierarchical variable resolution that respects scope boundaries</para></listitem>

        </varlistentry>
        <varlistentry>
          <term>Direct Variable Access</term>
          <listitem><para>Used for direct access to variable bindings
	  in pattern instantiation, with scope context passed to ensure
	  proper variable resolution</para></listitem>

        </varlistentry>
      </variablelist>

      <para>The scope-aware access patterns ensure that variable lookups
      respect SPARQL 1.1 semantic boundaries while maintaining backwards
      compatibility with existing code.</para>

    </section>

  </section>

  <section id="graph-pattern-management">
    <title>Graph Pattern Management</title>

    <para>Graph patterns are built during parsing through functions
    like
    <function>rasqal_new_basic_graph_pattern_from_formula</function>,
    which creates patterns from formula structures. The parser
    automatically adds pattern triples to the main query's triple
    sequence during pattern construction, which can cause variable
    scoping issues that require special handling.</para>

    <para>Filter expressions are attached to graph patterns and
    evaluated during pattern execution. The integration between graph
    patterns and filter expressions creates complex evaluation
    requirements, especially for nested patterns.</para>

    <para>Pattern integration assumes global pattern integration,
    requiring special handling for scoped sub-patterns that need
    isolation for proper scoping.</para>

  </section>



  <section id="query-transformation-system">
    <title>Query Transformation System</title>

    <para>The query transformer performs comprehensive variable analysis in <function>rasqal_query_build_variables_use</function>, analyzing variable scope and binding context, ensuring proper variable binding, and identifying unbound variable usage.</para>

    <para>The transformer prepares queries for optimization through constant folding, filter pushdown, and join reordering preparation. This phase is critical for query performance and correctness.</para>

    <section id="transformation-phases">
      <title>Transformation Phases</title>

      <para>The query transformation system performs several key phases,
      enhanced with scope-aware validation for SPARQL 1.1 compliance:</para>

      <orderedlist>
        <listitem><para><emphasis>Variable Analysis</emphasis> - Analyzes variable usage patterns and binding requirements across scope hierarchies</para></listitem>
        <listitem><para><emphasis>Scope Validation</emphasis> - Validates hierarchical variable scoping, ensures proper scope boundaries, and identifies unbound variables within appropriate scope contexts</para></listitem>
        <listitem><para><emphasis>Type Checking</emphasis> - Validates expression types and literal compatibility with scope-aware variable resolution</para></listitem>
        <listitem><para><emphasis>Constant Folding</emphasis> - Evaluates constant expressions at compile time while respecting scope isolation</para></listitem>
        <listitem><para><emphasis>Scope Optimization</emphasis> - Optimizes scope hierarchies and validates scope relationships for efficient evaluation</para></listitem>
        <listitem><para><emphasis>Optimization Preparation</emphasis> - Prepares query structures for optimization with scope-aware analysis</para></listitem>
      </orderedlist>

      <para>The scope-enhanced transformation phases ensure that SPARQL 1.1
      semantic isolation requirements are validated and maintained throughout
      the query processing pipeline.</para>

    </section>

  </section>

  <section id="triples-source-interface">
    <title>Triples Source Interface</title>

    <para>Rasqal abstracts data access through the triples source
    interface, which provides an abstract interface for data store
    access. This interface includes initialization, next match
    iteration, and finished state management.</para>

    <para>The triples source pattern involves binding known variables
    in triple patterns, querying the underlying data store, and
    iterating through matching triples.</para>

    <para>A key limitation is that the expression evaluation context
    doesn't provide direct access to triples source, making complex
    evaluation architecturally challenging and forcing reliance on
    heuristics rather than actual data lookup.</para>

    <section id="triples-source-operations">
      <title>Triples Source Operations</title>

      <para>The triples source interface provides the following operations:</para>

      <variablelist>
        <varlistentry>
          <term>Initialization</term>
          <listitem><para>Sets up the triples source for query execution</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Triple Matching</term>
          <listitem><para>Finds triples matching specified patterns</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Iteration</term>
          <listitem><para>Iterates through matching triples</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Cleanup</term>
          <listitem><para>Releases resources after query completion</para></listitem>
        </varlistentry>
      </variablelist>

    </section>

  </section>

  <section id="error-handling-and-validation">
    <title>Error Handling and Validation</title>

    <para>Rasqal implements multi-level validation across parse-time,
    transform-time, and runtime phases. Parse-time validation handles
    syntax and basic semantic validation, transform-time validation
    performs variable binding and scope validation, and runtime
    validation handles type checking and evaluation errors.</para>

    <para>Error propagation uses error flags passed through
    evaluation chains with early termination on error
    conditions.</para>

    <para>The query validation pipeline ensures queries go through
    comprehensive validation including lexical, syntactic, semantic,
    and runtime phases.</para>

    <section id="resource-management-validation">
      <title>Resource Management Validation</title>

      <para>The system includes comprehensive resource management
      validation to prevent memory leaks and corruption:</para>

      <itemizedlist>
        <listitem><para><emphasis>Reference Count
	Validation</emphasis> - Debug builds track reference count
	manipulations to detect leaks and premature
	frees</para></listitem>

        <listitem><para><emphasis>Ownership Validation</emphasis> -
	Functions validate that they properly transfer ownership of
	consumed parameters</para></listitem>

        <listitem><para><emphasis>Lifecycle Validation</emphasis> -
	The system validates that objects follow proper
	initialization and cleanup sequences</para></listitem>

        <listitem><para><emphasis>Memory Leak Detection</emphasis> -
	Integration with tools like AddressSanitizer enables
	automated detection of memory management
	issues</para></listitem>

      </itemizedlist>

      <para>These validation mechanisms have proven essential for
      maintaining system reliability, particularly in complex query
      patterns that stress the memory management system.</para>

    </section>

    <section id="validation-levels">
      <title>Validation Levels</title>

      <para>Rasqal implements validation at multiple levels:</para>

      <variablelist>
        <varlistentry>
          <term>Lexical Validation</term>
          <listitem><para>Validates token recognition and basic syntax</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Syntactic Validation</term>
          <listitem><para>Validates grammar rules and structure</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Semantic Validation</term>
          <listitem><para>Validates variable binding and scope</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Runtime Validation</term>
          <listitem><para>Validates expression evaluation and type checking</para></listitem>
        </varlistentry>
      </variablelist>

    </section>

  </section>



  <section id="performance-considerations">
    <title>Performance Considerations</title>

    <para>Lazy evaluation provides memory efficiency for large
    datasets, early termination possibilities, and streaming result
    processing. This architecture enables efficient handling of large
    result sets and complex queries.</para>

    <para>Optimization opportunities include leveraging RDF store
    indices, moving filters closer to data through filter pushdown,
    optimizing join execution order, and evaluating constants at
    compile time.</para>

    <para>Bottleneck areas include frequent literal value lookups
    during variable binding, complex expression tree evaluation,
    triple pattern evaluation, and frequent object creation and
    destruction during memory allocation.</para>

    <section id="memory-management-performance">
      <title>Memory Management Performance</title>

      <para>The reference counting system provides memory management
      with deterministic cleanup, but requires careful attention to
      avoid memory leaks:</para>

      <itemizedlist>
        <listitem><para><emphasis>Reference Count Overhead</emphasis>
        - Each object access requires reference count manipulation,
        which can become expensive in tight loops.</para></listitem>
        <listitem><para><emphasis>Circular Reference
        Prevention</emphasis> - Careful design is needed to avoid
        circular references that prevent cleanup.</para></listitem>
        <listitem><para><emphasis>Reset Handler Benefits</emphasis> -
        Rowsources with reset handlers avoid the overhead of row
        caching and the associated memory usage.</para></listitem>
        <listitem><para><emphasis>Consumption Semantics</emphasis> -
        Proper implementation of consumption semantics in functions
        like join operations prevents double-free conditions and
        improves performance.</para></listitem>
      </itemizedlist>

    </section>

    <section id="optimization-strategies">
      <title>Optimization Strategies</title>

      <para>Rasqal employs several optimization strategies:</para>

      <variablelist>
        <varlistentry>
          <term>Constant Folding</term>
          <listitem><para>Evaluates constant expressions at compile time</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Filter Pushdown</term>
          <listitem><para>Moves filters closer to data sources</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Join Reordering</term>
          <listitem><para>Optimizes join execution order</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Early Termination</term>
          <listitem><para>Stops processing when sufficient results are found</para></listitem>
        </varlistentry>
      </variablelist>

    </section>

  </section>

  <section id="module-architecture">
    <title>Module Architecture and Organization</title>

    <para>Rasqal's module architecture has been enhanced to support
    the hierarchical scope system while maintaining clean separation
    of concerns and extensible design patterns.</para>

    <section id="scope-management-modules">
      <title>Scope Management Modules</title>

      <para>The scope architecture is implemented across dedicated modules that
      provide the foundation for SPARQL 1.1 semantic isolation:</para>

      <variablelist>
        <varlistentry>
          <term>rasqal_query_scope.c</term>
          <listitem><para>Core scope management functions including creation,
          destruction, hierarchy management, and variable visibility computation.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>rasqal_query_transform.c</term>
          <listitem><para>Enhanced query transformation with scope hierarchy
          building and scope-aware variable analysis.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>rasqal_rowsource_filter.c</term>
          <listitem><para>Filter rowsource implementation with scope-aware
          variable resolution and proper variable scoping boundaries.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>rasqal_expression.c</term>
          <listitem><para>Enhanced expression evaluation with scope-aware
          variable resolution and scope context propagation.</para></listitem>
        </varlistentry>
      </variablelist>

    </section>

    <section id="module-integration-patterns">
      <title>Module Integration Patterns</title>

      <para>The scope architecture follows established Rasqal patterns
      for module integration:</para>

      <itemizedlist>
        <listitem><para><emphasis>Reference Counting</emphasis> - Scope
        objects use proper reference counting for memory management</para></listitem>
        <listitem><para><emphasis>C89 Compatibility</emphasis> - All scope
        functions maintain C89 compatibility for broad system support</para></listitem>
        <listitem><para><emphasis>Consistent Naming</emphasis> - Scope
        functions follow Rasqal naming conventions with appropriate
        prefixes</para></listitem>
        <listitem><para><emphasis>Error Handling</emphasis> - Scope modules
        implement consistent error reporting and cleanup patterns</para></listitem>
      </itemizedlist>

    </section>

  </section>

  <section id="extensibility-and-customization">
    <title>Extensibility and Customization</title>

    <para>Rasqal's architecture provides several extension points for
    customizing query behavior and adding new functionality:</para>

    <section id="custom-functions">
      <title>Custom Functions</title>

      <para>Developers can add custom functions to the expression
      system by implementing function registration and evaluation
      callbacks. This enables domain-specific functionality and
      integration with external systems.</para>

    </section>

    <section id="custom-triples-sources">
      <title>Custom Triples Sources</title>

      <para>The triples source interface allows implementing custom
      data access layers for different storage systems. This enables
      integration with various RDF stores and data sources.</para>

    </section>

    <section id="custom-rowsources">
      <title>Custom Rowsources</title>

      <para>The rowsource architecture supports implementing custom
      execution operators for specialized query processing
      requirements. This enables advanced optimization and
      domain-specific query features.</para>

      <para>When implementing custom rowsources, developers must
      carefully follow the established memory management
      patterns:</para>

      <itemizedlist>
        <listitem><para><emphasis>Reference Counting</emphasis> -
        Implement proper reference counting in the rowsource handler
        functions.</para></listitem>
        <listitem><para><emphasis>Reset Handlers</emphasis> - Provide
        reset handlers when possible to avoid row caching
        overhead.</para></listitem>
        <listitem><para><emphasis>Row Ownership</emphasis> - Follow
        consumption semantics where functions that take row
        parameters assume ownership.</para></listitem>
        <listitem><para><emphasis>Cleanup Handlers</emphasis> -
        Implement finish handlers to properly release all
        resources.</para></listitem>
      </itemizedlist>

      <para>Following these patterns ensures that custom rowsources
      integrate properly with the query engine's memory management
      system and don't introduce memory leaks or corruption.</para>

    </section>

  </section>

  <section id="best-practices">
    <title>Best Practices for Memory Management</title>

    <para>Here are some best practices for memory mamnagement in Rasqal:</para>

    <section id="rowsource-implementation-best-practices">
      <title>Rowsource Implementation</title>

      <itemizedlist>
        <listitem><para><emphasis>Always Implement Reset
	Handlers</emphasis> - Provide reset handlers whenever
	possible to avoid the SAVE_ROWS flag and associated memory
	overhead.</para></listitem>

        <listitem><para><emphasis>Follow Consumption
	Semantics</emphasis> - When functions consume parameters,
	document this clearly and set consumed pointers to NULL to
	prevent double-free.</para></listitem>

        <listitem><para><emphasis>Validate Reference
	Counts</emphasis> - Use debug builds to validate that
	reference counts behave as expected.</para></listitem>

        <listitem><para><emphasis>Test with Memory
	Debugging</emphasis> - Always test rowsource implementations
	with AddressSanitizer or similar tools.</para></listitem>

      </itemizedlist>

    </section>

    <section id="debugging-memory-issues">
      <title>Debugging Memory Issues</title>

      <itemizedlist>
        <listitem><para><emphasis>Use AddressSanitizer</emphasis> -
	Enable AddressSanitizer leak detection for comprehensive
	memory issue detection.</para></listitem>

        <listitem><para><emphasis>Enable Debug Logging</emphasis> -
	Use debug builds with reference count logging to trace object
	lifecycles.</para></listitem>

        <listitem><para><emphasis>Test Edge Cases</emphasis> - Pay
	special attention to empty patterns, optional joins, and
	other complex query structures.</para></listitem>

        <listitem><para><emphasis>Validate Cleanup</emphasis> -
	Ensure all objects reach zero reference count and are
	properly freed.</para></listitem>

      </itemizedlist>

    </section>

  </section>

</chapter>
